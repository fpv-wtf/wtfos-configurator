{"version":3,"file":"static/js/883.f7ac3533.chunk.js","mappings":"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","sources":["osd-overlay/shared.ts","osd-overlay/mp4/io/reader.ts","osd-overlay/mp4/io/writer.ts","osd-overlay/mp4/utils.ts","osd-overlay/mp4/parsers.ts","osd-overlay/mp4/writers.ts","osd-overlay/mp4/index.ts","osd-overlay/processor.ts","osd-overlay/fonts.ts","osd-overlay/osd.ts","osd-overlay/worker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import { FontPackFiles } from \"./fonts\";\n\nnamespace VideoWorkerShared {\n  export const enum MessageType {\n    COMPLETE,\n    ERROR,\n    PROGRESS_INIT,\n    PROGRESS_UPDATE,\n    START,\n  }\n\n  export interface CompleteMessage {\n    type: MessageType.COMPLETE;\n  }\n\n  export interface ErrorMessage {\n    type: MessageType.ERROR;\n    error: Error;\n  }\n\n  export interface ProgressInitMessage {\n    type: MessageType.PROGRESS_INIT;\n\n    expectedFrames: number;\n  }\n\n  export interface ProgressUpdateMessage {\n    type: MessageType.PROGRESS_UPDATE;\n\n    framesDecoded?: number;\n    framesDecodedMissing?: number;\n    framesEncoded?: number;\n    inDecoderQueue?: number;\n    inEncoderQueue?: number;\n    preview?: ImageBitmap;\n    queuedForDecode?: number;\n    queuedForEncode?: number;\n  }\n\n  export interface StartMessage {\n    type: MessageType.START;\n    fontFiles: FontPackFiles,\n    osdFile: File;\n    videoFile: File;\n    outHandle: FileSystemFileHandle;\n  }\n\n  export type Message =\n    | CompleteMessage\n    | ErrorMessage\n    | ProgressInitMessage\n    | ProgressUpdateMessage\n    | StartMessage;\n\n\n\n  export class DecoderError extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = \"DecoderError\";\n    }\n  }\n\n  export class DecoderConfigureError extends DecoderError {\n    constructor(message: string) {\n      super(message);\n      this.name = \"DecoderConfigureError\";\n    }\n  }\n\n  export class EncoderError extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = \"EncoderError\";\n    }\n  }\n\n  export class EncoderConfigureError extends EncoderError {\n    constructor(message: string) {\n      super(message);\n      this.name = \"EncoderConfigureError\";\n    }\n  }\n\n}\n\nexport default VideoWorkerShared;\n","export class FileStreamReader {\n  private static readonly BUFFER_SIZE = 1024 * 1024 * 8; // 8MB\n\n  private file: File;\n\n  private buffer = new ArrayBuffer(0);\n  private bufferOffset = 0;\n  private _offset = 0;\n\n  constructor(file: File) {\n    this.file = file;\n  }\n\n  async getNextString(length?: number): Promise<string> {\n    let bytes: Uint8Array;\n\n    if (length) {\n      bytes = await this.getNextBytes(length);\n    } else {\n      const byteBuffer = [];\n      let byte: number;\n      while ((byte = await this.getNextUint8()) !== 0) {\n        byteBuffer.push(byte);\n      }\n\n      bytes = new Uint8Array(byteBuffer);\n    }\n\n    const decoder = new TextDecoder();\n    const string = decoder.decode(bytes);\n    return string;\n  }\n\n  async getNextUint8(): Promise<number> {\n    const view = await this.getDataView(1);\n    return view.getUint8(0);\n  }\n\n  async getNextUint16(): Promise<number> {\n    const view = await this.getDataView(2);\n    return view.getUint16(0);\n  }\n\n  async getNextUint32(): Promise<number> {\n    const view = await this.getDataView(4);\n    return view.getUint32(0);\n  }\n\n  async getNextUint64(): Promise<bigint> {\n    const view = await this.getDataView(8);\n    return view.getBigUint64(0);\n  }\n\n  async getNextBytes(length: number): Promise<Uint8Array> {\n    const view = await this.getDataView(length);\n    const result = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n      result[i] = view.getUint8(i);\n    }\n\n    return result;\n  }\n\n  seek(offset: number) {\n    this._offset = offset;\n    if (\n      this._offset < this.bufferOffset ||\n      this._offset > this.bufferEndOffset\n    ) {\n      this.buffer = new ArrayBuffer(0);\n      this.bufferOffset = this._offset;\n    }\n  }\n\n  skip(length: number) {\n    this._offset += length;\n  }\n\n  get eof() {\n    return this.offset >= this.file.size;\n  }\n\n  get offset() {\n    return this._offset;\n  }\n\n  get size() {\n    return this.file.size;\n  }\n\n  private async fillBuffer(length: number) {\n    const fillEndOffset = this.offset + length;\n\n    if (fillEndOffset > this.bufferEndOffset) {\n      const newBufferOffset =\n        Math.floor(this.offset / FileStreamReader.BUFFER_SIZE) *\n        FileStreamReader.BUFFER_SIZE;\n      const newBufferEndOffset =\n        Math.ceil(fillEndOffset / FileStreamReader.BUFFER_SIZE) *\n        FileStreamReader.BUFFER_SIZE;\n\n      this.buffer = await this.file\n        .slice(newBufferOffset, newBufferEndOffset)\n        .arrayBuffer();\n      this.bufferOffset = newBufferOffset;\n    }\n  }\n\n  private async getDataView(length: number): Promise<DataView> {\n    await this.fillBuffer(length);\n\n    const result = new DataView(\n      this.buffer,\n      this.offset - this.bufferOffset,\n      length\n    );\n    this._offset += length;\n    return result;\n  }\n\n  private get bufferEndOffset() {\n    return this.bufferOffset + this.buffer.byteLength;\n  }\n}\n","export class FileStreamWriter {\n  private readonly file: FileSystemFileHandle;\n  private stream?: FileSystemWritableFileStream;\n\n  private buffer?: ArrayBuffer;\n\n  private uint8Buffer?: Uint8Array;\n  private uint16Buffer?: Uint16Array;\n  private uint32Buffer?: Uint32Array;\n  private uint64Buffer?: BigUint64Array;\n\n  private uint16View?: DataView;\n  private uint32View?: DataView;\n  private uint64View?: DataView;\n\n  private _offset = 0;\n  private _size = 0;\n\n  constructor(file: FileSystemFileHandle) {\n    this.file = file;\n\n    this.buffer = new ArrayBuffer(8);\n\n    this.uint8Buffer = new Uint8Array(this.buffer, 0, 1);\n    this.uint16Buffer = new Uint16Array(this.buffer, 0, 1);\n    this.uint32Buffer = new Uint32Array(this.buffer, 0, 1);\n    this.uint64Buffer = new BigUint64Array(this.buffer, 0, 1);\n\n    this.uint16View = new DataView(this.buffer, 0, 2);\n    this.uint32View = new DataView(this.buffer, 0, 4);\n    this.uint64View = new DataView(this.buffer, 0, 8);\n  }\n\n  async writeNextUint8(value: number): Promise<void> {\n    this.uint8Buffer![0] = value;\n\n    await this.writeNextBytes(this.uint8Buffer!);\n  }\n\n  async writeNextUint16(value: number): Promise<void> {\n    this.uint16View!.setUint16(0, value, false);\n    await this.writeNextBytes(this.uint16Buffer!);\n  }\n\n  async writeNextUint32(value: number): Promise<void> {\n    this.uint32View!.setUint32(0, value, false);\n    await this.writeNextBytes(this.uint32Buffer!);\n  }\n\n  async writeNextUint64(value: number | bigint): Promise<void> {\n    if (typeof value === \"number\") {\n      value = BigInt(value);\n    }\n\n    this.uint64View!.setBigUint64(0, value, false);\n    await this.writeNextBytes(this.uint64Buffer!);\n  }\n\n  async writeNextString(value: string, length?: number): Promise<void> {\n    const buffer = new Uint8Array(\n      length !== undefined ? length : value.length + 1\n    );\n\n    const encoder = new TextEncoder();\n    encoder.encodeInto(value, buffer);\n\n    await this.writeNextBytes(buffer);\n  }\n\n  async writeNextBytes(bytes: BufferSource | Blob): Promise<void> {\n    const stream = await this.getStream();\n    await stream.write(bytes)\n\n    const byteLength = bytes instanceof Blob ? bytes.size : bytes.byteLength;\n    this._offset += byteLength;\n    this._size += byteLength;\n  }\n\n  async skip(length: number) {\n    await this.seek(this.offset + length);\n  }\n\n  async seek(offset: number) {\n    const stream = await this.getStream();\n    await stream.seek(offset);\n    this._offset = offset;\n  }\n\n  async close() {\n    const stream = await this.getStream();\n    await stream.close();\n    this.stream = undefined;\n  }\n\n  private async getStream(): Promise<FileSystemWritableFileStream> {\n    if (!this.stream) {\n      this.stream = await this.file.createWritable();\n      await this.stream.truncate(0);\n\n      this._size = 0;\n      this._offset = 0;\n    }\n\n    return this.stream;\n  }\n\n  get offset(): number {\n    return this._offset;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n}\n","/**\n * Convert a date to a time in seconds since 1904-01-01T00:00:00Z, as used by\n * MP4 files.\n * @param date Date to convert. If not provided, the current date is used.\n * @returns Number of seconds since 1904-01-01T00:00:00Z\n */\nexport function getMp4Time(date?: Date): number {\n  if (date === undefined) {\n    date = new Date();\n  }\n\n  const startDate = new Date(\"1904-01-01T00:00:00Z\");\n  const diffSeconds = Math.floor(\n    (date.getTime() - startDate.getTime()) / 1000\n  );\n\n  return diffSeconds;\n}\n","import { FileStreamReader } from \"./io/reader\";\nimport {\n  Avc1Box,\n  AvcCBox,\n  BaseBox,\n  BaseFullBox,\n  Box,\n  BoxHeader,\n  BoxType,\n  Co64Box,\n  DinfBox,\n  DrefBox,\n  FtypBox,\n  FullBoxHeader,\n  HdlrBox,\n  MdatBox,\n  MdhdBox,\n  MdiaBox,\n  MinfBox,\n  MoovBox,\n  MvhdBox,\n  SampleEntryBox,\n  StblBox,\n  StcoBox,\n  StscBox,\n  StsdBox,\n  StssBox,\n  StszBox,\n  SttsBox,\n  TkhdBox,\n  TrakBox,\n  UdtaBox,\n  UnknownBox,\n  UrlBox,\n  UrnBox,\n  VmhdBox,\n} from \"./types\";\n\nexport async function parseBox(stream: FileStreamReader): Promise<Box> {\n  const startOffset = stream.offset;\n\n  let size = await stream.getNextUint32();\n  const type = await stream.getNextString(4);\n\n  if (size === 0) {\n    size = stream.size - startOffset;\n    console.debug(\n      `${type} box has size 0, must continue until end of file: ${size}`\n    );\n  } else if (size === 1) {\n    // Not actually 64-bits but 9007TB is enough for any one box, I'm sure.\n    size = Number(await stream.getNextUint64());\n    console.debug(`${type} box has big size: ${size}`);\n  }\n\n  const boxParsers: Record<\n    string,\n    new (\n      stream: FileStreamReader,\n      startOffset: number,\n      size: number,\n      type: string\n    ) => BoxParser<Box>\n  > = {\n    \"url \": UrlBoxParser,\n    \"urn \": UrnBoxParser,\n    avc1: Avc1BoxParser,\n    avcC: AvcCBoxParser,\n    co64: Co64BoxParser,\n    dinf: DinfBoxParser,\n    dref: DrefBoxParser,\n    ftyp: FtypBoxParser,\n    hdlr: HdrlBoxParser,\n    mdat: MdatBoxParser,\n    mdhd: MdhdBoxParser,\n    mdia: MdiaBoxParser,\n    minf: MinfBoxParser,\n    moov: MoovBoxParser,\n    mvhd: MvhdBoxParser,\n    stbl: StblBoxParser,\n    stco: StcoBoxParser,\n    stsc: StscBoxParser,\n    stsd: StsdBoxParser,\n    stss: StssBoxParser,\n    stsz: StszBoxParser,\n    stts: SttsBoxParser,\n    tkhd: TkhdBoxParser,\n    trak: TrakBoxParser,\n    udta: UdtaBoxParser,\n    vmhd: VmhdBoxParser,\n  };\n\n  let parser: BoxParser<Box>;\n  if (boxParsers[type]) {\n    parser = new boxParsers[type](stream, startOffset, size, type);\n  } else {\n    console.warn(\n      `No parser available for %c${type}`,\n      \"text-decoration: underline\"\n    );\n    parser = new UnknownBoxParser(stream, startOffset, size, type);\n  }\n\n  return await parser.parse();\n}\n\nabstract class BoxParser<T extends BaseBox> {\n  protected readonly stream: FileStreamReader;\n  protected readonly size: number;\n  protected readonly type: string;\n  protected readonly startOffset: number;\n\n  protected readonly header: BoxHeader;\n\n  constructor(\n    stream: FileStreamReader,\n    startOffset: number,\n    size: number,\n    type: string\n  ) {\n    this.stream = stream;\n    this.startOffset = startOffset;\n    this.size = size;\n    this.type = type;\n\n    this.header = this.getHeader();\n  }\n\n  private getHeader(): BoxHeader {\n    const endOffset = this.startOffset + this.size;\n\n    return {\n      size: this.size,\n      type: this.type,\n\n      startOffset: this.startOffset,\n      endOffset,\n    };\n  }\n\n  protected async getChildBoxes(): Promise<Partial<Record<BoxType, Box[]>>> {\n    const boxes: Partial<Record<BoxType, Box[]>> = {};\n\n    while (this.stream.offset < this.header.endOffset) {\n      const box = await this.getNextChildBox();\n\n      if (box.type === \"unknown\") {\n        console.warn(\n          `Child box %c${box.header!.type}%c in %c${\n            this.type\n          }%c is unknown, ignoring.`,\n          \"text-decoration: underline\",\n          \"text-decoration: none\",\n          \"text-decoration: underline\",\n          \"text-decoration: none\"\n        );\n      }\n\n      if (!(box.type in boxes)) {\n        boxes[box.type] = [];\n      }\n\n      boxes[box.type]!.push(box);\n    }\n\n    return boxes;\n  }\n\n  protected async getNextChildBox(): Promise<Box> {\n    return await parseBox(this.stream);\n  }\n\n  protected seekToEnd(): void {\n    if (this.stream.offset !== this.header.endOffset) {\n      const diff = this.header.endOffset - this.stream.offset;\n      console.warn(\n        `Box %c${this.header.type}%c was not fully parsed! Stopped ${diff}B early.`,\n        \"text-decoration: underline\",\n        \"text-decoration: none\",\n        this.header\n      );\n    }\n\n    this.stream.seek(this.header.endOffset);\n  }\n\n  abstract parse(): Promise<T>;\n}\n\nabstract class SimpleBoxParser<T extends BaseBox> extends BoxParser<T> {\n  async parse(): Promise<T> {\n    const box = await this.parseBox(this.header);\n    this.seekToEnd();\n    return box;\n  }\n\n  protected abstract parseBox(header: BoxHeader): Promise<T>;\n}\n\nabstract class FullBoxParser<T extends BaseFullBox> extends BoxParser<T> {\n  protected async getFullBoxHeader() {\n    const version = await this.stream.getNextUint8();\n    const flags =\n      ((await this.stream.getNextUint8()) << 16) |\n      ((await this.stream.getNextUint8()) << 8) |\n      (await this.stream.getNextUint8());\n\n    return {\n      version,\n      flags,\n    };\n  }\n\n  async parse(): Promise<T> {\n    const fullBoxHeader = await this.getFullBoxHeader();\n    const box = await this.parseBox(this.header, fullBoxHeader);\n    this.seekToEnd();\n    return box;\n  }\n\n  protected abstract parseBox(\n    header: BoxHeader,\n    fullHeader: FullBoxHeader\n  ): Promise<T>;\n}\n\nclass FtypBoxParser extends SimpleBoxParser<FtypBox> {\n  async parseBox(header: BoxHeader): Promise<FtypBox> {\n    const majorBrand = await this.stream.getNextString(4);\n    const minorVersion = await this.stream.getNextUint32();\n    const compatibleBrands = [];\n\n    while (this.stream.offset < header.endOffset) {\n      compatibleBrands.push(await this.stream.getNextString(4));\n    }\n\n    return {\n      type: \"ftyp\",\n      header,\n      majorBrand,\n      minorVersion,\n      compatibleBrands,\n    };\n  }\n}\n\nclass MdatBoxParser extends SimpleBoxParser<MdatBox> {\n  async parseBox(header: BoxHeader): Promise<MdatBox> {\n    this.stream.seek(this.header.endOffset);\n\n    return {\n      type: \"mdat\",\n      header,\n    };\n  }\n}\n\nclass MoovBoxParser extends SimpleBoxParser<MoovBox> {\n  async parseBox(header: BoxHeader): Promise<MoovBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      type: \"moov\",\n      header,\n      mvhd: childBoxes.mvhd![0] as MvhdBox,\n      trak: childBoxes.trak as TrakBox[],\n    };\n  }\n}\n\nclass MvhdBoxParser extends FullBoxParser<MvhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<MvhdBox> {\n    if (fullBoxHeader.version === 1) {\n      throw new Error(\"Version 1 not supported\");\n    }\n\n    const creationTime = await this.stream.getNextUint32();\n    const modificationTime = await this.stream.getNextUint32();\n    const timescale = await this.stream.getNextUint32();\n    const duration = await this.stream.getNextUint32();\n    const rate = await this.stream.getNextUint32();\n    const volume = await this.stream.getNextUint16();\n\n    // Reserved.\n    await this.stream.getNextUint16();\n    await this.stream.getNextUint32();\n    await this.stream.getNextUint32();\n\n    const matrix = [];\n    for (let i = 0; i < 9; i++) {\n      matrix.push(await this.stream.getNextUint32());\n    }\n\n    // Predefined.\n    for (let i = 0; i < 6; i++) {\n      await this.stream.getNextUint32();\n    }\n\n    const nextTrackId = await this.stream.getNextUint32();\n\n    return {\n      header,\n      type: \"mvhd\",\n      fullBoxHeader,\n      creationTime,\n      modificationTime,\n      timescale,\n      duration,\n      rate,\n      volume,\n      matrix,\n      nextTrackId,\n    };\n  }\n}\n\nclass TrakBoxParser extends SimpleBoxParser<TrakBox> {\n  async parseBox(header: BoxHeader): Promise<TrakBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"trak\",\n      tkhd: childBoxes.tkhd![0] as TkhdBox,\n      mdia: childBoxes.mdia![0] as MdiaBox,\n    };\n  }\n}\n\nclass TkhdBoxParser extends FullBoxParser<TkhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<TkhdBox> {\n    if (fullBoxHeader.version === 1) {\n      throw new Error(\"Version 1 not supported\");\n    }\n\n    const creationTime = await this.stream.getNextUint32();\n    const modificationTime = await this.stream.getNextUint32();\n    const trackId = await this.stream.getNextUint32();\n    await this.stream.getNextUint32(); // Reserved\n    const duration = await this.stream.getNextUint32();\n\n    await this.stream.getNextUint32(); // Reserved\n    await this.stream.getNextUint32(); // Reserved\n\n    const layer = await this.stream.getNextUint16();\n    const alternateGroup = await this.stream.getNextUint16();\n    const volume = await this.stream.getNextUint16();\n\n    await this.stream.getNextUint16(); // Reserved.\n\n    const matrix = [];\n    for (let i = 0; i < 9; i++) {\n      matrix.push(await this.stream.getNextUint32());\n    }\n\n    const width = (await this.stream.getNextUint32()) >> 16;\n    const height = (await this.stream.getNextUint32()) >> 16;\n\n    return {\n      header,\n      type: \"tkhd\",\n      fullBoxHeader,\n      creationTime,\n      modificationTime,\n      trackId,\n      duration,\n      layer,\n      alternateGroup,\n      volume,\n      matrix,\n      width,\n      height,\n    };\n  }\n}\n\nclass MdiaBoxParser extends SimpleBoxParser<MdiaBox> {\n  async parseBox(header: BoxHeader): Promise<MdiaBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"mdia\",\n      mdhd: childBoxes.mdhd![0] as MdhdBox,\n      minf: childBoxes.minf![0] as MinfBox,\n      hdlr: childBoxes.hdlr![0] as HdlrBox,\n    };\n  }\n}\n\nclass MdhdBoxParser extends FullBoxParser<MdhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<MdhdBox> {\n    if (fullBoxHeader.version === 1) {\n      throw new Error(\"Version 1 not supported\");\n    }\n\n    const creationTime = await this.stream.getNextUint32();\n    const modificationTime = await this.stream.getNextUint32();\n    const timescale = await this.stream.getNextUint32();\n    const duration = await this.stream.getNextUint32();\n\n    const languageBytes = await this.stream.getNextUint16();\n    let language = \"\";\n    for (let i = 0; i < 3; i++) {\n      language += String.fromCharCode(0x60 + ((languageBytes >> (2 - i) * 5) & 0x1f));\n    }\n\n    await this.stream.getNextUint16(); // Reserved.\n\n    return {\n      header,\n      type: \"mdhd\",\n      fullBoxHeader,\n      creationTime,\n      modificationTime,\n      timescale,\n      duration,\n      language,\n    };\n  }\n}\n\nclass MinfBoxParser extends SimpleBoxParser<MinfBox> {\n  async parseBox(header: BoxHeader): Promise<MinfBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"minf\",\n      vmhd: \"vmhd\" in childBoxes ? (childBoxes.vmhd![0] as VmhdBox) : undefined,\n      stbl: childBoxes.stbl![0] as StblBox,\n      dinf: childBoxes.dinf![0] as DinfBox,\n    };\n  }\n}\n\nclass StblBoxParser extends SimpleBoxParser<StblBox> {\n  async parseBox(header: BoxHeader): Promise<StblBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"stbl\",\n      stco: childBoxes.stco?.[0] as StcoBox,\n      co64: childBoxes.co64?.[0] as Co64Box,\n      stsc: childBoxes.stsc![0] as StscBox,\n      stsd: childBoxes.stsd![0] as StsdBox,\n      stss: childBoxes.stss![0] as StssBox,\n      stsz: childBoxes.stsz![0] as StszBox,\n      stts: childBoxes.stts![0] as SttsBox,\n    };\n  }\n}\n\nclass StsdBoxParser extends FullBoxParser<StsdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StsdBox> {\n    const entryCount = await this.stream.getNextUint32();\n\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      const nextChild = (await this.getNextChildBox()) as SampleEntryBox;\n      entries.push(nextChild);\n    }\n\n    return {\n      header,\n      type: \"stsd\",\n      fullBoxHeader,\n      entries,\n    };\n  }\n}\n\nclass Avc1BoxParser extends SimpleBoxParser<Avc1Box> {\n  async parseBox(header: BoxHeader): Promise<Avc1Box> {\n    // Reserved\n    for (let i = 0; i < 6; i++) {\n      await this.stream.getNextUint8();\n    }\n\n    const dataReferenceIndex = await this.stream.getNextUint16();\n\n    // Technically from VisualSampleEntry but...\n    for (let i = 0; i < 2; i++) {\n      await this.stream.getNextUint16(); // Reserved\n    }\n    for (let i = 0; i < 3; i++) {\n      await this.stream.getNextUint32(); // Reserved\n    }\n\n    const width = await this.stream.getNextUint16();\n    const height = await this.stream.getNextUint16();\n    const horizontalResolution = await this.stream.getNextUint32();\n    const verticalResolution = await this.stream.getNextUint32();\n\n    await this.stream.getNextUint32(); // Reserved\n\n    const frameCount = await this.stream.getNextUint16();\n    const compressorName = await this.stream.getNextString(32);\n    const depth = await this.stream.getNextUint16();\n\n    await this.stream.getNextUint16(); // Reserved\n\n    const avcC = (await this.getNextChildBox()) as AvcCBox;\n\n    return {\n      header,\n      type: \"avc1\",\n      avcC,\n      compressorName,\n      dataReferenceIndex,\n      depth,\n      frameCount,\n      height,\n      horizontalResolution,\n      verticalResolution,\n      width,\n    };\n  }\n}\n\nclass AvcCBoxParser extends SimpleBoxParser<AvcCBox> {\n  async parseBox(header: BoxHeader): Promise<AvcCBox> {\n    const configurationVersion = await this.stream.getNextUint8();\n    const profileIndication = await this.stream.getNextUint8();\n    const profileCompatibility = await this.stream.getNextUint8();\n    const levelIndication = await this.stream.getNextUint8();\n    const lengthSizeMinusOne = (await this.stream.getNextUint8()) & 0x3;\n\n    const spsCount = (await this.stream.getNextUint8()) & 0x1f;\n    const sps = [];\n    for (let i = 0; i < spsCount; i++) {\n      const spsLength = await this.stream.getNextUint16();\n      const spsData = await this.stream.getNextBytes(spsLength);\n      sps.push(spsData);\n    }\n\n    const ppsCount = await this.stream.getNextUint8();\n    const pps = [];\n    for (let i = 0; i < ppsCount; i++) {\n      const ppsLength = await this.stream.getNextUint16();\n      const ppsData = await this.stream.getNextBytes(ppsLength);\n      pps.push(ppsData);\n    }\n\n    return {\n      header,\n      type: \"avcC\",\n      configurationVersion,\n      profileIndication,\n      profileCompatibility,\n      levelIndication,\n      lengthSizeMinusOne,\n      sequenceParameterSets: sps,\n      pictureParameterSets: pps,\n    };\n  }\n}\n\nclass StssBoxParser extends FullBoxParser<StssBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StssBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const sampleNumbers = [];\n    for (let i = 0; i < entryCount; i++) {\n      sampleNumbers.push(await this.stream.getNextUint32());\n    }\n\n    return {\n      header,\n      type: \"stss\",\n      fullBoxHeader,\n      sampleNumbers,\n    };\n  }\n}\n\nclass StcoBoxParser extends FullBoxParser<StcoBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StcoBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const chunkOffsets = [];\n    for (let i = 0; i < entryCount; i++) {\n      chunkOffsets.push(await this.stream.getNextUint32());\n    }\n\n    return {\n      header,\n      type: \"stco\",\n      fullBoxHeader,\n      chunkOffsets,\n    };\n  }\n}\n\nclass Co64BoxParser extends FullBoxParser<Co64Box> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<Co64Box> {\n    const entryCount = await this.stream.getNextUint32();\n    const chunkOffsets = [];\n    for (let i = 0; i < entryCount; i++) {\n      chunkOffsets.push(Number(await this.stream.getNextUint64()));\n    }\n\n    return {\n      header,\n      type: \"co64\",\n      fullBoxHeader,\n      chunkOffsets,\n    };\n  }\n}\n\nclass StscBoxParser extends FullBoxParser<StscBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StscBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      entries.push({\n        firstChunk: await this.stream.getNextUint32(),\n        samplesPerChunk: await this.stream.getNextUint32(),\n        sampleDescriptionIndex: await this.stream.getNextUint32(),\n      });\n    }\n\n    return {\n      header,\n      type: \"stsc\",\n      fullBoxHeader,\n      entries,\n    };\n  }\n}\n\nclass StszBoxParser extends FullBoxParser<StszBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StszBox> {\n    let sampleSizes = [await this.stream.getNextUint32()];\n    const sampleCount = await this.stream.getNextUint32();\n\n    // If sample size is 0, then we have a table of sample sizes, otherwise\n    // all samples are the same size.\n    if (sampleSizes[0] === 0) {\n      sampleSizes = [];\n      for (let i = 0; i < sampleCount; i++) {\n        sampleSizes.push(await this.stream.getNextUint32());\n      }\n    }\n\n    return {\n      header,\n      type: \"stsz\",\n      fullBoxHeader,\n      sampleSizes,\n      sampleCount,\n    };\n  }\n}\n\nclass SttsBoxParser extends FullBoxParser<SttsBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<SttsBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      entries.push({\n        sampleCount: await this.stream.getNextUint32(),\n        sampleDelta: await this.stream.getNextUint32(),\n      });\n    }\n\n    return {\n      header,\n      type: \"stts\",\n      fullBoxHeader,\n      entries,\n    };\n  }\n}\n\nclass UdtaBoxParser extends SimpleBoxParser<UdtaBox> {\n  async parseBox(header: BoxHeader): Promise<UdtaBox> {\n    // TODO: Not fully parsed.\n    await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"udta\",\n    };\n  }\n}\n\nclass HdrlBoxParser extends FullBoxParser<HdlrBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<HdlrBox> {\n    await this.stream.getNextUint32(); // Predefined\n\n    const handlerType = await this.stream.getNextString(4);\n\n    for (let i = 0; i < 3; i++) {\n      await this.stream.getNextUint32(); // Reserved\n    }\n\n    const name = await this.stream.getNextString();\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"hdlr\",\n      handlerType,\n      name,\n    };\n  }\n}\n\nclass VmhdBoxParser extends FullBoxParser<VmhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<VmhdBox> {\n    const graphicsMode = await this.stream.getNextUint16();\n    const opColor = [\n      await this.stream.getNextUint16(),\n      await this.stream.getNextUint16(),\n      await this.stream.getNextUint16(),\n    ];\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"vmhd\",\n      graphicsMode,\n      opColor,\n    };\n  }\n}\n\nclass DrefBoxParser extends FullBoxParser<DrefBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<DrefBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      entries.push((await this.getNextChildBox()) as UrlBox | UrnBox);\n    }\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"dref\",\n      entries,\n    };\n  }\n}\n\nclass DinfBoxParser extends SimpleBoxParser<DinfBox> {\n  async parseBox(header: BoxHeader): Promise<DinfBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"dinf\",\n      dref: childBoxes.dref![0] as DrefBox,\n    };\n  }\n}\n\nclass UrnBoxParser extends FullBoxParser<UrnBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<UrnBox> {\n    let name: string = \"\";\n    let location: string = \"\";\n    if (fullBoxHeader.flags !== 1) {\n      name = await this.stream.getNextString();\n      location = await this.stream.getNextString();\n    }\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"urn \",\n      name,\n      location,\n    };\n  }\n}\n\nclass UrlBoxParser extends FullBoxParser<UrlBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<UrlBox> {\n    let location: string = \"\";\n    if (fullBoxHeader.flags !== 1) {\n      location = await this.stream.getNextString();\n    }\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"url \",\n      location,\n    };\n  }\n}\n\nclass UnknownBoxParser extends SimpleBoxParser<UnknownBox> {\n  async parseBox(header: BoxHeader): Promise<UnknownBox> {\n    this.stream.seek(this.header.endOffset);\n\n    return {\n      header,\n      type: \"unknown\",\n    };\n  }\n}\n","import { FileStreamWriter } from \"./io/writer\";\nimport {\n  Avc1Box,\n  AvcCBox,\n  BaseBox,\n  BaseFullBox,\n  Box,\n  DinfBox,\n  DrefBox,\n  FtypBox,\n  HdlrBox,\n  MdhdBox,\n  MdiaBox,\n  MinfBox,\n  MoovBox,\n  MvhdBox,\n  StblBox,\n  StcoBox,\n  StscBox,\n  StsdBox,\n  StssBox,\n  StszBox,\n  SttsBox,\n  TkhdBox,\n  TrakBox,\n  UrlBox,\n  UrnBox,\n  VmhdBox,\n} from \"./types\";\n\nexport async function writeBox(\n  stream: FileStreamWriter,\n  box: Box\n): Promise<void> {\n  const boxWriters: Record<\n    string,\n    new (writer: FileStreamWriter) => BoxWriter<Box>\n  > = {\n    \"url \": UrlBoxWriter,\n    \"urn \": UrnBoxWriter,\n    avc1: Avc1BoxWriter,\n    avcC: AvcCBoxWriter,\n    dinf: DinfBoxWriter,\n    dref: DrefBoxWriter,\n    ftyp: FtypBoxWriter,\n    hdlr: HdlrBoxWriter,\n    mdhd: MdhdBoxWriter,\n    mdia: MdiaBoxWriter,\n    minf: MinfBoxWriter,\n    moov: MoovBoxWriter,\n    mvhd: MvhdBoxWriter,\n    stbl: StblBoxWriter,\n    stco: StcoBoxWriter,\n    stsc: StscBoxWriter,\n    stsd: StsdBoxWriter,\n    stss: StssBoxWriter,\n    stsz: StszBoxWriter,\n    stts: SttsBoxWriter,\n    tkhd: TkhdBoxWriter,\n    trak: TrakBoxWriter,\n    vmhd: VmhdBoxWriter,\n  };\n\n  let writer = boxWriters[box.type];\n  if (!writer) {\n    console.warn(\n      `No writer available for %c${box.type}, not writing.`,\n      \"text-decoration: underline\"\n    );\n  }\n\n  await new writer(stream).write(box);\n}\n\nabstract class BoxWriter<T extends BaseBox> {\n  constructor(protected readonly stream: FileStreamWriter) {}\n\n  async write(box: T): Promise<void> {\n    const startOffset = this.stream.offset;\n    await this.stream.writeNextUint32(0);\n    await this.stream.writeNextString(box.type, 4);\n\n    await this.writeContents(box);\n\n    const endOffset = this.stream.offset;\n    const size = endOffset - startOffset;\n    await this.stream.seek(startOffset);\n    await this.stream.writeNextUint32(size);\n\n    await this.stream.seek(endOffset);\n  }\n\n  abstract writeContents(box: T): Promise<void>;\n}\n\nabstract class FullBoxWriter<T extends BaseFullBox> extends BoxWriter<T> {\n  async writeContents(box: T): Promise<void> {\n    await this.stream.writeNextUint8(box.fullBoxHeader!.version);\n\n    await this.stream.writeNextUint8(box.fullBoxHeader!.flags >> 16);\n    await this.stream.writeNextUint8(box.fullBoxHeader!.flags >> 8);\n    await this.stream.writeNextUint8(box.fullBoxHeader!.flags);\n  }\n}\n\nexport class FtypBoxWriter extends BoxWriter<FtypBox> {\n  async writeContents(box: FtypBox): Promise<void> {\n    await this.stream.writeNextString(box.majorBrand, 4);\n    await this.stream.writeNextUint32(box.minorVersion);\n\n    for (const compatibleBrand of box.compatibleBrands) {\n      await this.stream.writeNextString(compatibleBrand, 4);\n    }\n  }\n}\n\nexport class AvcCBoxWriter extends BoxWriter<AvcCBox> {\n  async writeContents(box: AvcCBox): Promise<void> {\n    await this.stream.writeNextUint8(box.configurationVersion);\n\n    await this.stream.writeNextUint8(box.profileIndication);\n    await this.stream.writeNextUint8(box.profileCompatibility);\n    await this.stream.writeNextUint8(box.levelIndication);\n    await this.stream.writeNextUint8(box.lengthSizeMinusOne | 0xfc);\n\n    await this.stream.writeNextUint8(box.sequenceParameterSets.length | 0xe0);\n    for (const sequenceParameterSet of box.sequenceParameterSets) {\n      await this.stream.writeNextUint16(sequenceParameterSet.byteLength);\n      await this.stream.writeNextBytes(sequenceParameterSet);\n    }\n\n    await this.stream.writeNextUint8(box.pictureParameterSets.length);\n    for (const pictureParameterSets of box.pictureParameterSets) {\n      await this.stream.writeNextUint16(pictureParameterSets.byteLength);\n      await this.stream.writeNextBytes(pictureParameterSets);\n    }\n  }\n}\n\nexport class Avc1BoxWriter extends BoxWriter<Avc1Box> {\n  // TODO: Generalise as a SampleEntryBoxWriter\n\n  async writeContents(box: Avc1Box): Promise<void> {\n    // From SampleEntry\n    await this.stream.skip(6);\n    await this.stream.writeNextUint16(box.dataReferenceIndex);\n\n    // From VisualSampleEntry\n    await this.stream.skip(2 * 2 + 4 * 3);\n\n    await this.stream.writeNextUint16(box.width);\n    await this.stream.writeNextUint16(box.height);\n\n    await this.stream.writeNextUint32(box.horizontalResolution);\n    await this.stream.writeNextUint32(box.verticalResolution);\n\n    await this.stream.skip(4);\n\n    await this.stream.writeNextUint16(box.frameCount);\n    await this.stream.writeNextString(box.compressorName, 32);\n    await this.stream.writeNextUint16(box.depth);\n\n    await this.stream.writeNextUint16(0xffff);\n\n    // From AVCSampleEntry\n    await writeBox(this.stream, box.avcC);\n  }\n}\n\nexport class StsdBoxWriter extends FullBoxWriter<StsdBox> {\n  async writeContents(box: StsdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await writeBox(this.stream, entry);\n    }\n  }\n}\n\nexport class StblBoxWriter extends BoxWriter<StblBox> {\n  async writeContents(box: StblBox): Promise<void> {\n    if (box.stco && box.co64) {\n      throw new Error(\"stbl box cannot contain both stco and co64\");\n    }\n\n    if (box.stco) {\n      await writeBox(this.stream, box.stco);\n    } else if (box.co64) {\n      await writeBox(this.stream, box.co64);\n    }\n\n    await writeBox(this.stream, box.stsc);\n    await writeBox(this.stream, box.stsd);\n    await writeBox(this.stream, box.stss);\n    await writeBox(this.stream, box.stsz);\n    await writeBox(this.stream, box.stts);\n  }\n}\n\nexport class UrlBoxWriter extends FullBoxWriter<UrlBox> {\n  async writeContents(box: UrlBox): Promise<void> {\n    await super.writeContents(box);\n\n    if (box.fullBoxHeader!.flags !== 1) {\n      await this.stream.writeNextString(box.location);\n    }\n  }\n}\n\nexport class UrnBoxWriter extends FullBoxWriter<UrnBox> {\n  async writeContents(box: UrnBox): Promise<void> {\n    await super.writeContents(box);\n\n    if (box.fullBoxHeader!.flags !== 1) {\n      await this.stream.writeNextString(box.name);\n      await this.stream.writeNextString(box.location);\n    }\n  }\n}\n\nexport class DinfBoxWriter extends BoxWriter<DinfBox> {\n  async writeContents(box: DinfBox): Promise<void> {\n    await writeBox(this.stream, box.dref);\n  }\n}\n\nexport class DrefBoxWriter extends FullBoxWriter<DrefBox> {\n  async writeContents(box: DrefBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await writeBox(this.stream, entry);\n    }\n  }\n}\n\nexport class VmhdBoxWriter extends FullBoxWriter<VmhdBox> {\n  async writeContents(box: VmhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint16(box.graphicsMode);\n    for (const color of box.opColor) {\n      await this.stream.writeNextUint16(color);\n    }\n  }\n}\n\nexport class HdlrBoxWriter extends FullBoxWriter<HdlrBox> {\n  async writeContents(box: HdlrBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.skip(4);\n    await this.stream.writeNextString(box.handlerType, 4);\n    await this.stream.skip(4 * 3);\n    await this.stream.writeNextString(box.name);\n  }\n}\n\nexport class StcoBoxWriter extends FullBoxWriter<StcoBox> {\n  async writeContents(box: StcoBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.chunkOffsets.length);\n    for (const chunkOffset of box.chunkOffsets) {\n      await this.stream.writeNextUint32(chunkOffset);\n    }\n  }\n}\n\nexport class StszBoxWriter extends FullBoxWriter<StszBox> {\n  async writeContents(box: StszBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(\n      box.sampleSizes.length > 1 ? 0 : box.sampleSizes[0]\n    );\n    await this.stream.writeNextUint32(box.sampleCount);\n    for (const sampleSize of box.sampleSizes) {\n      await this.stream.writeNextUint32(sampleSize);\n    }\n  }\n}\n\nexport class StscBoxWriter extends FullBoxWriter<StscBox> {\n  async writeContents(box: StscBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await this.stream.writeNextUint32(entry.firstChunk);\n      await this.stream.writeNextUint32(entry.samplesPerChunk);\n      await this.stream.writeNextUint32(entry.sampleDescriptionIndex);\n    }\n  }\n}\n\nexport class SttsBoxWriter extends FullBoxWriter<SttsBox> {\n  async writeContents(box: SttsBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await this.stream.writeNextUint32(entry.sampleCount);\n      await this.stream.writeNextUint32(entry.sampleDelta);\n    }\n  }\n}\n\nexport class StssBoxWriter extends FullBoxWriter<StssBox> {\n  async writeContents(box: StssBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.sampleNumbers.length);\n    for (const sampleNumber of box.sampleNumbers) {\n      await this.stream.writeNextUint32(sampleNumber);\n    }\n  }\n}\n\nexport class MdhdBoxWriter extends FullBoxWriter<MdhdBox> {\n  async writeContents(box: MdhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.creationTime);\n    await this.stream.writeNextUint32(box.modificationTime);\n    await this.stream.writeNextUint32(box.timescale);\n    await this.stream.writeNextUint32(box.duration);\n\n    await this.stream.writeNextUint16(0x55c4); // ISO-639-2/T code for \"undetermined\"\n    await this.stream.skip(2);\n  }\n}\n\nexport class TkhdBoxWriter extends FullBoxWriter<TkhdBox> {\n  async writeContents(box: TkhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.creationTime);\n    await this.stream.writeNextUint32(box.modificationTime);\n    await this.stream.writeNextUint32(box.trackId);\n\n    await this.stream.skip(4);\n\n    await this.stream.writeNextUint32(box.duration);\n\n    await this.stream.skip(4 * 2);\n\n    await this.stream.writeNextUint16(box.layer);\n    await this.stream.writeNextUint16(box.alternateGroup);\n    await this.stream.writeNextUint16(box.volume);\n\n    await this.stream.skip(2);\n\n    for (const matrix of box.matrix) {\n      await this.stream.writeNextUint32(matrix);\n    }\n\n    await this.stream.writeNextUint32(box.width);\n    await this.stream.writeNextUint32(box.height);\n  }\n}\n\nexport class MvhdBoxWriter extends FullBoxWriter<MvhdBox> {\n  async writeContents(box: MvhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.creationTime);\n    await this.stream.writeNextUint32(box.modificationTime);\n    await this.stream.writeNextUint32(box.timescale);\n    await this.stream.writeNextUint32(box.duration);\n\n    await this.stream.writeNextUint32(box.rate);\n    await this.stream.writeNextUint16(box.volume);\n\n    await this.stream.skip(2 + 4 * 2);\n\n    for (const matrix of box.matrix) {\n      await this.stream.writeNextUint32(matrix);\n    }\n\n    await this.stream.skip(4 * 6);\n\n    await this.stream.writeNextUint32(box.nextTrackId);\n  }\n}\n\nexport class MinfBoxWriter extends BoxWriter<MinfBox> {\n  async writeContents(box: MinfBox): Promise<void> {\n    await writeBox(this.stream, box.vmhd!);\n    await writeBox(this.stream, box.dinf!);\n    await writeBox(this.stream, box.stbl!);\n  }\n}\n\nexport class MdiaBoxWriter extends BoxWriter<MdiaBox> {\n  async writeContents(box: MdiaBox): Promise<void> {\n    await writeBox(this.stream, box.mdhd!);\n    await writeBox(this.stream, box.hdlr!);\n    await writeBox(this.stream, box.minf!);\n  }\n}\n\nexport class TrakBoxWriter extends BoxWriter<TrakBox> {\n  async writeContents(box: TrakBox): Promise<void> {\n    await writeBox(this.stream, box.tkhd!);\n    await writeBox(this.stream, box.mdia!);\n  }\n}\n\nexport class MoovBoxWriter extends BoxWriter<MoovBox> {\n  async writeContents(box: MoovBox): Promise<void> {\n    await writeBox(this.stream, box.mvhd!);\n    for (const trak of box.trak) {\n      await writeBox(this.stream, trak);\n    }\n  }\n}\n\nexport class MdatBoxStreamWriter {\n  private startOffset: number = 0;\n  private sizeOffset: number = 0;\n\n  private opened = false;\n  private closed = false;\n\n  constructor(private readonly stream: FileStreamWriter) {}\n\n  async open() {\n    if (this.opened) {\n      throw new Error(\"already opened\");\n    } else if (this.closed) {\n      throw new Error(\"already closed\");\n    }\n\n    this.startOffset = this.stream.offset;\n    await this.stream.writeNextUint32(1);\n    await this.stream.writeNextString(\"mdat\", 4);\n\n    this.sizeOffset = this.stream.offset;\n    await this.stream.writeNextUint64(0);\n\n    this.opened = true;\n  }\n\n  async write(bytes: Blob | BufferSource): Promise<void> {\n    if (!this.opened) {\n      throw new Error(\"not opened\");\n    } else if (this.closed) {\n      throw new Error(\"already closed\");\n    }\n\n    await this.stream.writeNextBytes(bytes);\n  }\n\n  async close() {\n    if (!this.opened) {\n      throw new Error(\"not opened\");\n    } else if (this.closed) {\n      throw new Error(\"already closed\");\n    }\n\n    const endOffset = this.stream.offset;\n\n    await this.stream.seek(this.sizeOffset);\n    await this.stream.writeNextUint64(endOffset - this.startOffset);\n    await this.stream.seek(endOffset);\n\n    this.closed = true;\n  }\n\n  get dataStartOffset(): number {\n    if (!this.opened) {\n      throw new Error(\"not opened\");\n    }\n\n    return this.startOffset + 16;\n  }\n}\n","import { FileStreamReader } from \"./io/reader\";\nimport { FileStreamWriter } from \"./io/writer\";\nimport {\n  Avc1Box,\n  AvcCBox,\n  Box,\n  DinfBox,\n  DrefBox,\n  FtypBox,\n  HdlrBox,\n  MdatBox,\n  MdhdBox,\n  MdiaBox,\n  MinfBox,\n  MoovBox,\n  MvhdBox,\n  StblBox,\n  StcoBox,\n  StscBox,\n  StsdBox,\n  StssBox,\n  StszBox,\n  SttsBox,\n  TkhdBox,\n  TrakBox,\n  UrlBox,\n  VmhdBox,\n} from \"./types\";\nimport { getMp4Time } from \"./utils\";\nimport { parseBox } from \"./parsers\";\nimport { writeBox, MdatBoxStreamWriter } from \"./writers\";\n\nexport class MP4Parser {\n  private readonly stream: FileStreamReader;\n  mdat?: MdatBox;\n  moov?: MoovBox;\n\n  constructor(file: File) {\n    this.stream = new FileStreamReader(file);\n  }\n\n  async parse(): Promise<void> {\n    const ftyp = await this.parseBox();\n    if (ftyp.type !== \"ftyp\") {\n      throw new Error(\"Expected ftyp box at start of file. Not an MP4?\");\n    }\n\n    let mdat: MdatBox | undefined;\n    let moov: MoovBox | undefined;\n\n    while (!this.stream.eof) {\n      const box = await this.parseBox();\n\n      switch (box.type) {\n        case \"mdat\":\n          mdat = box;\n          break;\n        case \"moov\":\n          moov = box;\n          break;\n        default:\n          break;\n      }\n    }\n\n    if (!mdat || !moov) {\n      throw new Error(\"Missing mdat or moov box\");\n    }\n\n    this.mdat = mdat;\n    this.moov = moov;\n  }\n\n  async getSample(sampleNumber: number): Promise<{\n    data: Uint8Array;\n    sync: boolean;\n  }> {\n    const stbl = this.moov!.trak[0].mdia.minf.stbl;\n    const stsz = stbl.stsz;\n    const stco = stbl.stco ? stbl.stco : stbl.co64;\n\n    const sampleSize = stsz.sampleSizes[sampleNumber];\n\n    let chunkOffset = stco!.chunkOffsets[0];\n    let sampleOffset = chunkOffset;\n    for (let i = 0; i < sampleNumber; i++) {\n      sampleOffset += stbl.stsz.sampleSizes[i];\n    }\n\n    this.stream.seek(sampleOffset);\n    return {\n      data: await this.stream.getNextBytes(sampleSize),\n      sync: this.isSampleSync(sampleNumber),\n    };\n  }\n\n  isSampleSync(sampleNumber: number): boolean {\n    const stbl = this.moov!.trak[0].mdia.minf.stbl;\n    return stbl.stss.sampleNumbers.includes(sampleNumber + 1);\n  }\n\n  private async parseBox(): Promise<Box> {\n    return await parseBox(this.stream);\n  }\n}\n\nexport class MP4Writer {\n  private readonly stream: FileStreamWriter;\n  private readonly mdat: MdatBoxStreamWriter;\n  private avcC?: AvcCBox;\n\n  private sampleCount = 0;\n  private syncSamples: number[] = [];\n  private sampleSizes: number[] = [];\n\n  private displaySize?: { width: number; height: number };\n  private frameRate: number = 60;\n\n  constructor(file: FileSystemFileHandle) {\n    this.stream = new FileStreamWriter(file);\n    this.mdat = new MdatBoxStreamWriter(this.stream);\n  }\n\n  async open(): Promise<void> {\n    const ftyp: FtypBox = {\n      type: \"ftyp\",\n      majorBrand: \"isom\",\n      minorVersion: 0,\n      compatibleBrands: [\"mp41\", \"avc1\", \"isom\"],\n    };\n\n    await writeBox(this.stream, ftyp);\n    await this.mdat.open();\n  }\n\n  async writeSample(data: Blob | BufferSource, sync: boolean) {\n    await this.mdat.write(data);\n\n    if (sync) {\n      this.syncSamples.push(this.sampleCount + 1);\n    }\n\n    this.sampleSizes.push(data instanceof Blob ? data.size : data.byteLength);\n    this.sampleCount++;\n  }\n\n  setAvcC(avcCStruct: ArrayBuffer | ArrayBufferView) {\n    // TODO: Make a nice stream view for this.\n    let view: DataView;\n    if (avcCStruct instanceof ArrayBuffer) {\n      view = new DataView(avcCStruct);\n    } else {\n      view = new DataView(\n        avcCStruct.buffer,\n        avcCStruct.byteOffset,\n        avcCStruct.byteLength\n      );\n    }\n\n    let avcC: AvcCBox = {\n      type: \"avcC\",\n      configurationVersion: view.getUint8(0),\n      profileIndication: view.getUint8(1),\n      profileCompatibility: view.getUint8(2),\n      levelIndication: view.getUint8(3),\n      lengthSizeMinusOne: view.getUint8(4) & 0x3,\n      sequenceParameterSets: [],\n      pictureParameterSets: [],\n    } as AvcCBox;\n\n    let offset: number = 5;\n\n    const spsCount = view.getUint8(offset) & 0x1f;\n    offset += 1;\n\n    const sps = [];\n    for (let i = 0; i < spsCount; i++) {\n      const spsLength = view.getUint16(offset);\n      offset += 2;\n\n      const spsData = new Uint8Array(\n        view.buffer,\n        view.byteOffset + offset,\n        spsLength\n      );\n      sps.push(spsData);\n      offset += spsLength;\n    }\n\n    const ppsCount = view.getUint8(offset);\n    offset += 1;\n\n    const pps = [];\n    for (let i = 0; i < ppsCount; i++) {\n      const ppsLength = view.getUint16(offset);\n      offset += 2;\n\n      const ppsData = new Uint8Array(\n        view.buffer,\n        view.byteOffset + offset,\n        ppsLength\n      );\n      pps.push(ppsData);\n      offset += ppsLength;\n    }\n\n    avcC.sequenceParameterSets = sps;\n    avcC.pictureParameterSets = pps;\n\n    this.avcC = avcC;\n  }\n\n  setDisplaySize(options: { width: number; height: number }) {\n    this.displaySize = {\n      width: options.width,\n      height: options.height,\n    };\n  }\n\n  setFramerate(framerate: number) {\n    this.frameRate = framerate;\n  }\n\n  async close() {\n    await this.mdat.close();\n\n    const moov: MoovBox = {\n      type: \"moov\",\n      mvhd: this.getMvhdBox(),\n      trak: [this.getTrakBox()],\n    };\n\n    await writeBox(this.stream, moov);\n    await this.stream.close();\n  }\n\n  private getTrakBox(): TrakBox {\n    return {\n      type: \"trak\",\n      tkhd: this.getTkhdBox(),\n      mdia: this.getMdiaBox(),\n    };\n  }\n\n  private getTkhdBox(): TkhdBox {\n    const now = new Date();\n    const nowMp4Time = getMp4Time(now);\n\n    return {\n      type: \"tkhd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0x3, // Enabled and in movie\n      },\n      alternateGroup: 0,\n      creationTime: nowMp4Time,\n      duration: this.sampleCount * 60,\n      width: this.displaySize!.width,\n      height: this.displaySize!.height,\n      layer: 0,\n      matrix: [0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000],\n      modificationTime: nowMp4Time,\n      trackId: 1,\n      volume: 0,\n    };\n  }\n\n  private getMvhdBox(): MvhdBox {\n    const now = new Date();\n    const nowMp4Time = getMp4Time(now);\n\n    return {\n      type: \"mvhd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      duration: Math.floor((this.sampleCount * 1000) / this.frameRate),\n      creationTime: nowMp4Time,\n      modificationTime: nowMp4Time,\n      timescale: 1000,\n      rate: 0x00010000,\n      volume: 0x0100,\n      matrix: [0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000],\n      nextTrackId: 2,\n    };\n  }\n\n  private getMdiaBox(): MdiaBox {\n    return {\n      type: \"mdia\",\n      hdlr: {\n        type: \"hdlr\",\n        fullBoxHeader: {\n          version: 0,\n          flags: 0,\n        },\n        handlerType: \"vide\",\n        name: \"VideoHandler\",\n      } as HdlrBox,\n      minf: this.getMinfBox(),\n      mdhd: this.getMdhdBox(),\n    } as MdiaBox;\n  }\n\n  private getMdhdBox(): MdhdBox {\n    const now = new Date();\n    const nowMp4Time = getMp4Time(now);\n\n    return {\n      type: \"mdhd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      creationTime: nowMp4Time,\n      duration: this.sampleCount,\n      language: \"\",\n      modificationTime: nowMp4Time,\n      timescale: this.frameRate,\n    };\n  }\n\n  private getMinfBox(): MinfBox {\n    const stbl = this.getStblBox();\n    const dinf = this.getDinfBox();\n\n    return {\n      type: \"minf\",\n      dinf,\n      stbl,\n      vmhd: {\n        type: \"vmhd\",\n        fullBoxHeader: {\n          version: 0,\n          flags: 1,\n        },\n        graphicsMode: 0,\n        opColor: [0, 0, 0],\n      } as VmhdBox,\n    };\n  }\n\n  private getDinfBox(): DinfBox {\n    // Always reports that the data is in the same file.\n    return {\n      type: \"dinf\",\n      dref: {\n        type: \"dref\",\n        fullBoxHeader: {\n          version: 0,\n          flags: 0,\n        },\n        entries: [\n          {\n            type: \"url \",\n            fullBoxHeader: {\n              version: 0,\n              flags: 1,\n            },\n            location: \"\",\n          } as UrlBox,\n        ],\n      } as DrefBox,\n    } as DinfBox;\n  }\n\n  private getStblBox(): StblBox {\n    const stco: StcoBox = {\n      type: \"stco\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      chunkOffsets: [this.mdat.dataStartOffset],\n    };\n\n    const stsc: StscBox = {\n      type: \"stsc\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      entries: [\n        {\n          firstChunk: 1,\n          samplesPerChunk: this.sampleCount,\n          sampleDescriptionIndex: 1,\n        },\n      ],\n    };\n\n    const stsd: StsdBox = {\n      type: \"stsd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      entries: [\n        {\n          type: \"avc1\",\n          dataReferenceIndex: 1,\n          width: this.displaySize!.width,\n          height: this.displaySize!.height,\n          horizontalResolution: 0x00480000,\n          verticalResolution: 0x00480000,\n          frameCount: 1,\n          compressorName: \"mp4.ts\",\n          depth: 24,\n          avcC: this.avcC!,\n        } as Avc1Box,\n      ],\n    };\n\n    const stss: StssBox = {\n      type: \"stss\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      sampleNumbers: this.syncSamples,\n    };\n\n    const stsz: StszBox = {\n      type: \"stsz\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      sampleCount: this.sampleCount,\n      sampleSizes: this.sampleSizes,\n    };\n\n    const stts: SttsBox = {\n      type: \"stts\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      entries: [\n        {\n          sampleCount: this.sampleCount,\n          sampleDelta: 1,\n        },\n      ],\n    };\n\n    const stbl: StblBox = {\n      type: \"stbl\",\n      stco,\n      stsc,\n      stsd,\n      stss,\n      stsz,\n      stts,\n    };\n\n    return stbl;\n  }\n}\n","/* eslint-disable no-restricted-globals */\nimport { StreamDataView } from \"stream-data-view\";\n\nimport VideoWorkerShared from \"./shared\";\nimport { MP4Parser, MP4Writer } from \"./mp4\";\nimport { Avc1Box, AvcCBox } from \"./mp4/types\";\n\nconst PROGRESS_UPDATE_INTERVAL = 100;\n\nfunction avcCBoxToDescription(avcCBox: AvcCBox): ArrayBuffer {\n  const stream = new StreamDataView(undefined, true);\n\n  stream.setNextUint8(avcCBox.configurationVersion);\n  stream.setNextUint8(avcCBox.profileIndication);\n  stream.setNextUint8(avcCBox.profileCompatibility);\n  stream.setNextUint8(avcCBox.levelIndication);\n  stream.setNextUint8(avcCBox.lengthSizeMinusOne + (63 << 2));\n\n  stream.setNextUint8(avcCBox.sequenceParameterSets.length + (7 << 5));\n  for (let i = 0; i < avcCBox.sequenceParameterSets.length; i++) {\n    stream.setNextUint16(avcCBox.sequenceParameterSets[i].length);\n    for (let j = 0; j < avcCBox.sequenceParameterSets[i].length; j++) {\n      stream.setNextUint8(avcCBox.sequenceParameterSets[i][j]);\n    }\n  }\n\n  stream.setNextUint8(avcCBox.pictureParameterSets.length);\n  for (let i = 0; i < avcCBox.pictureParameterSets.length; i++) {\n    stream.setNextUint16(avcCBox.pictureParameterSets[i].length);\n    for (let j = 0; j < avcCBox.pictureParameterSets[i].length; j++) {\n      stream.setNextUint8(avcCBox.pictureParameterSets[i][j]);\n    }\n  }\n\n  return stream.getBuffer();\n}\n\ntype ModifyFrameCallback = (frame: ImageBitmap, index: number) => ImageBitmap;\n\ntype ProgressInitCallback = (options: {\n  expectedFrames: number;\n}) => void;\n\ntype ProgressCallback = (options: {\n  framesDecoded?: number;\n  framesDecodedMissing?: number;\n  framesEncoded?: number;\n  preview?: ImageBitmap;\n  queuedForDecode?: number;\n  queuedForEncode?: number;\n  inEncoderQueue?: number;\n  inDecoderQueue?: number;\n}) => void;\n\nexport interface ProcessorOptions {\n  modifyFrame: ModifyFrameCallback;\n  progressInit: ProgressInitCallback;\n  progressUpdate: ProgressCallback;\n}\n\ninterface DecodedFrame {\n  index: number;\n  image?: ImageBitmap\n  sync: boolean;\n}\n\ninterface EncodedFrame {\n  data: ArrayBuffer;\n  timestamp: number;\n  sync: boolean;\n}\n\nexport class Processor {\n  decoder?: VideoDecoder;\n  encoder?: VideoEncoder;\n\n  inMp4?: MP4Parser;\n  outMp4?: MP4Writer;\n\n  expectedFrames: number = 0;\n  framesDecoded: number = 0;\n  framesDecodedMissing: number = 0;\n  framesEncoded: number = 0;\n  queuedForDecode: number = 0;\n  queuedForEncode: number = 0;\n\n  modifyFrame: ModifyFrameCallback;\n  progressInit: ProgressInitCallback;\n  progressUpdate: ProgressCallback;\n\n  processResolve?: () => void;\n  processReject?: (reason?: any) => void;\n\n  progressUpdateIntervalHandle?: number;\n\n  decodedFrames: Record<number, DecodedFrame> = {};\n  encodedFrames: EncodedFrame[] = [];\n\n  constructor(options: ProcessorOptions) {\n    this.modifyFrame = options.modifyFrame;\n    this.progressInit = options.progressInit;\n    this.progressUpdate = options.progressUpdate;\n\n    this.sendProgressUpdate = this.sendProgressUpdate.bind(this);\n  }\n\n  async open(file: File, outHandle: FileSystemFileHandle) {\n    this.reset();\n\n    this.inMp4 = new MP4Parser(file);\n    await this.inMp4.parse();\n\n    this.outMp4 = new MP4Writer(outHandle);\n    await this.outMp4.open();\n\n    return {\n      width: this.inMp4.moov!.trak[0].tkhd.width,\n      height: this.inMp4.moov!.trak[0].tkhd.height,\n    };\n  }\n\n  process(options: { width: number; height: number }): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.processResolve = resolve;\n      this.processReject = reject;\n\n      try {\n        const avc1box = this.inMp4!.moov!.trak[0].mdia.minf.stbl.stsd\n          .entries[0] as Avc1Box;\n        const codec =\n          \"avc1.\" +\n          avc1box.avcC.profileIndication.toString(16).padStart(2, \"0\") +\n          avc1box.avcC.profileCompatibility.toString(16).padStart(2, \"0\") +\n          avc1box.avcC.levelIndication.toString(16).padStart(2, \"0\");\n\n        this.decoder!.configure({\n          codec: codec,\n          codedWidth: this.inMp4!.moov!.trak[0].tkhd.width,\n          codedHeight: this.inMp4!.moov!.trak[0].tkhd.height,\n          description: avcCBoxToDescription(\n            (this.inMp4!.moov!.trak[0].mdia.minf.stbl.stsd.entries[0] as Avc1Box)\n              .avcC\n          ),\n          optimizeForLatency: false,\n        });\n      } catch (e: any) {\n        throw new VideoWorkerShared.DecoderConfigureError(e);\n      }\n\n      try {\n        let bitrate =\n          (this.inMp4!.mdat!.header!.size * 8 * this.inMp4!.moov!.mvhd.timescale) /\n          this.inMp4!.moov!.mvhd.duration;\n        bitrate = Math.ceil(bitrate / 5_000_000) * 5_000_000;\n\n        this.encoder!.configure({\n          bitrate: bitrate,\n          codec: \"avc1.42003d\",\n          framerate: 60,\n          height: options.height,\n          latencyMode: \"quality\",\n          scalabilityMode: \"L1T2\",\n          width: options.width,\n        });\n      } catch (e: any) {\n        throw new VideoWorkerShared.EncoderConfigureError(e);\n      }\n\n      this.outMp4?.setDisplaySize({\n        width: options.width,\n        height: options.height,\n      });\n\n      this.outMp4?.setFramerate(60);\n\n      this.expectedFrames = this.inMp4!.moov!.trak[0].mdia.mdhd.duration;\n      this.decodedFrames = {};\n\n      this.progressInit({\n        expectedFrames: this.expectedFrames,\n      });\n\n      this.progressUpdateIntervalHandle = self.setInterval(this.sendProgressUpdate, PROGRESS_UPDATE_INTERVAL);\n\n      this.processSamples();\n    });\n  }\n\n  private reset() {\n    if (this.encoder) {\n      this.encoder.close();\n    }\n\n    this.encoder = new VideoEncoder({\n      output: this.handleEncodedFrame.bind(this),\n      error: this.handleEncoderError.bind(this),\n    });\n\n    if (this.decoder) {\n      this.decoder.close();\n    }\n\n    this.decoder = new VideoDecoder({\n      output: this.handleDecodedFrame.bind(this),\n      error: this.handleDecoderError.bind(this),\n    });\n\n    this.expectedFrames = 0;\n    this.framesDecoded = 0;\n    this.framesDecodedMissing = 0;\n    this.framesEncoded = 0;\n    this.queuedForDecode = 0;\n    this.queuedForEncode = 0;\n\n    this.processResolve = undefined;\n    this.processReject = undefined;\n\n    if (this.progressUpdateIntervalHandle) {\n      clearInterval(this.progressUpdateIntervalHandle);\n    }\n  }\n\n  private async processSamples() {\n    let lastSampleIndex = 0;\n    while (lastSampleIndex < this.expectedFrames) {\n      // Load samples up to next keyframe.\n      const sampleChunks = [];\n      for (let sampleIndex = lastSampleIndex; sampleIndex < this.expectedFrames; sampleIndex++) {\n        const sample = await this.inMp4!.getSample(sampleIndex);\n        sampleChunks.push({\n          index: sampleIndex,\n          data: sample.data.buffer,\n          sync: sample.sync,\n        });\n\n        if (sampleIndex + 1 < this.expectedFrames && this.inMp4!.isSampleSync(sampleIndex + 1)) {\n          break;\n        }\n      }\n\n      // Prepare expected frames object, which the callback will toot into.\n      this.decodedFrames = {};\n      for (const chunk of sampleChunks) {\n        this.decodedFrames[chunk.index] = {\n          index: chunk.index,\n          image: undefined,\n          sync: chunk.sync,\n        }\n      }\n\n      // Enqueue samples for decoding.\n      for (const chunk of sampleChunks) {\n        const encodedChunk = new EncodedVideoChunk({\n          type: chunk.sync ? \"key\" : \"delta\",\n          timestamp: chunk.index,\n          duration: 16670,\n          data: chunk.data,\n        });\n\n        this.decoder!.decode(encodedChunk);\n        lastSampleIndex = chunk.index + 1;\n        this.queuedForDecode++;\n      }\n\n      // Wait for all samples to be decoded.\n      await this.decoder!.flush();\n\n      // Modify and enque frames for encoding.\n      this.encodedFrames = [];\n      for (const [index, entry] of Object.values(this.decodedFrames).entries()) {\n        if (!entry.image) {\n          console.error(`Frame ${entry.index} was never decoded!`);\n          this.framesDecodedMissing++;\n          continue;\n        }\n\n        const modifiedFrame = this.modifyFrame(entry.image!, entry.index);\n        const frame = new VideoFrame(modifiedFrame, {\n          duration: 16670,\n          timestamp: entry.index,\n        });\n\n        // Send first frame as preview. This needs to happen after constructing the frame otherwise\n        // it complains that \"the image source is detached\" which is completely ungooglable.\n        if (index === 0) {\n          this.progressUpdate({\n            preview: modifiedFrame\n          })\n        }\n\n        this.encoder!.encode(frame, { keyFrame: entry.sync });\n        this.queuedForEncode++;\n        frame.close();\n      }\n\n      // Wait for all frames to be encoded.\n      await this.encoder!.flush();\n\n      // Write encoded frames to output.\n      for (const frame of this.encodedFrames) {\n        this.outMp4!.writeSample(frame.data, frame.sync);\n      }\n    }\n\n    await this.outMp4!.close();\n    this.sendProgressUpdate();\n    this.processResolve!();\n  }\n\n  private async handleDecodedFrame(frame: VideoFrame) {\n    this.framesDecoded++;\n    this.decodedFrames[frame.timestamp!].image = await createImageBitmap(frame);\n    frame.close();\n  }\n\n  private handleEncodedFrame(\n    chunk: EncodedVideoChunk,\n    metadata: EncodedVideoChunkMetadata\n  ) {\n    this.framesEncoded++;\n\n    const buffer = new ArrayBuffer(chunk.byteLength);\n    chunk.copyTo(buffer);\n    this.encodedFrames.push({\n      data: buffer,\n      sync: chunk.type === \"key\",\n      timestamp: chunk.timestamp,\n    });\n\n    // avcC is only available on the first frame.\n    if (chunk.timestamp === 0) {\n      this.outMp4!.setAvcC(metadata.decoderConfig?.description!);\n    }\n  }\n\n  private handleDecoderError(e: Error) {\n    this.processReject!(new VideoWorkerShared.DecoderError(e.message));\n    throw e;\n  }\n\n  private handleEncoderError(e: Error) {\n    this.processReject!(new VideoWorkerShared.EncoderError(e.message));\n    throw e;\n  }\n\n  private sendProgressUpdate() {\n    this.progressUpdate({\n      framesDecoded: this.framesDecoded,\n      framesDecodedMissing: this.framesDecodedMissing,\n      framesEncoded: this.framesEncoded,\n      queuedForDecode: this.queuedForDecode,\n      queuedForEncode: this.queuedForEncode,\n      inDecoderQueue: this.decoder?.decodeQueueSize,\n      inEncoderQueue: this.encoder?.encodeQueueSize,\n    });\n  }\n}\n","export const SD_TILE_WIDTH = 12 * 3;\nexport const SD_TILE_HEIGHT = 18 * 3;\n\nexport const HD_TILE_WIDTH = 12 * 2;\nexport const HD_TILE_HEIGHT = 18 * 2;\n\nexport const TILES_PER_PAGE = 256;\n\nexport interface FontPack {\n  sd1: Font;\n  sd2: Font;\n  hd1: Font;\n  hd2: Font;\n}\n\nexport interface FontPackFiles {\n  sd1: File;\n  sd2: File;\n  hd1: File;\n  hd2: File;\n}\n\nexport class Font {\n  readonly name: string;\n  readonly tiles: ImageBitmap[];\n\n  constructor(name: string, tiles: ImageBitmap[]) {\n    this.name = name;\n    this.tiles = tiles;\n  }\n\n  getTile(index: number): ImageBitmap {\n    return this.tiles[index];\n  }\n\n  static async fromFile(file: File): Promise<Font> {\n    const data = await file.arrayBuffer();\n    const isHd = file.name.includes(\"hd\");\n\n    const tileWidth = isHd ? HD_TILE_WIDTH : SD_TILE_WIDTH;\n    const tileHeight = isHd ? HD_TILE_HEIGHT : SD_TILE_HEIGHT;\n\n    const tiles: ImageBitmap[] = [];\n    for (let tileIndex = 0; tileIndex < TILES_PER_PAGE; tileIndex++) {\n      const pixData = new Uint8ClampedArray(\n        data,\n        tileIndex * tileWidth * tileHeight * 4,\n        tileWidth * tileHeight * 4\n      );\n\n      const imageData = new ImageData(pixData, tileWidth, tileHeight);\n      const imageBitmap = await createImageBitmap(imageData);\n      tiles.push(imageBitmap);\n    }\n\n    return new Font(file.name, tiles);\n  }\n\n  static async fromFiles(files: FontPackFiles): Promise<FontPack> {\n    return {\n      sd1: await Font.fromFile(files.sd1),\n      sd2: await Font.fromFile(files.sd2),\n      hd1: await Font.fromFile(files.hd1),\n      hd2: await Font.fromFile(files.hd2),\n    };\n  }\n}\n","import { StreamDataView } from \"stream-data-view\";\n\ninterface OsdHeader {\n  magic: string;\n  version: number;\n  config: OsdConfig;\n}\n\ninterface OsdConfig {\n  charWidth: number;\n  charHeight: number;\n  fontWidth: number;\n  fontHeight: number;\n  xOffset: number;\n  yOffset: number;\n  fontVariant: number;\n}\n\ninterface OsdFrame {\n  frameNumber: number;\n  frameSize: number;\n  frameData: Uint16Array;\n}\n\nexport class OsdReader {\n  readonly header: OsdHeader;\n  readonly frames: OsdFrame[] = [];\n\n  constructor(data: ArrayBuffer) {\n    const stream = new StreamDataView(data);\n    this.header = {\n      magic: stream.getNextString(7),\n      version: stream.getNextUint16(),\n      config: {\n        charWidth: stream.getNextUint8(),\n        charHeight: stream.getNextUint8(),\n        fontWidth: stream.getNextUint8(),\n        fontHeight: stream.getNextUint8(),\n        xOffset: stream.getNextUint16(),\n        yOffset: stream.getNextUint16(),\n        fontVariant: stream.getNextUint8(),\n      },\n    };\n\n    if (this.header.config.charWidth === 31) {\n      this.header.config.charWidth = 30;\n    }\n\n    while (stream.getOffset() < data.byteLength) {\n      try {\n        const frameNumber = stream.getNextUint32();\n        const frameSize = stream.getNextUint32();\n        const frameData = new Uint16Array(data, stream.getOffset(), frameSize);\n        stream.setOffset(stream.getOffset() + frameSize * 2);\n\n        this.frames.push({\n          frameNumber,\n          frameSize,\n          frameData,\n        });\n      } catch (e) {\n        if (e instanceof RangeError) {\n          console.warn(\"No more data in OSD file, probably truncated due to power loss\");\n          break;\n        }\n      }\n    }\n  }\n\n  static async fromFile(file: File): Promise<OsdReader> {\n    const data = await file.arrayBuffer();\n    return new OsdReader(data);\n  }\n}\n","/// <reference lib=\"webworker\" />\n\nimport VideoWorkerShared from \"./shared\";\nimport { Processor } from \"./processor\";\nimport {\n  Font,\n  FontPack,\n  FontPackFiles,\n  TILES_PER_PAGE,\n} from \"./fonts\";\nimport { OsdReader } from \"./osd\";\n\nconst MAX_DISPLAY_X = 60;\nconst MAX_DISPLAY_Y = 22;\n\nexport class VideoWorker {\n  readonly processor: Processor;\n  fontPack?: FontPack;\n  osdReader?: OsdReader;\n\n  lastOsdIndex: number = 0;\n\n  wide: boolean = false;\n  hd: boolean = false;\n  outWidth?: number;\n  outHeight?: number;\n\n  osdCanvas?: OffscreenCanvas;\n  osdCtx?: OffscreenCanvasRenderingContext2D;\n  frameCanvas?: OffscreenCanvas;\n  frameCtx?: OffscreenCanvasRenderingContext2D;\n\n  constructor() {\n    this.processor = new Processor({\n      modifyFrame: this.modifyFrame.bind(this),\n      progressInit: this.progressInit.bind(this),\n      progressUpdate: this.progressUpdate.bind(this),\n    });\n\n    addEventListener(\"message\", this.onMessage.bind(this)); // eslint-disable-line no-restricted-globals\n  }\n\n  async start(options: {\n    fontFiles: FontPackFiles,\n    osdFile: File,\n    videoFile: File,\n    outHandle: FileSystemFileHandle,\n  }) {\n    this.osdReader = await OsdReader.fromFile(options.osdFile);\n    this.fontPack = await Font.fromFiles(options.fontFiles);\n\n    const { width, height } = await this.processor.open(options.videoFile, options.outHandle);\n\n    if (width === 1280 && height === 720) {\n      this.wide = true;\n    }\n\n    if (this.osdReader!.header.config.fontWidth === 24) {\n      this.hd = true;\n    }\n\n    let outWidth: number;\n    let outHeight: number;\n    if (this.wide || this.hd) {\n      outWidth = 1280;\n      outHeight = 720;\n    } else {\n      outWidth = width;\n      outHeight = height;\n    }\n\n    this.outWidth = outWidth;\n    this.outHeight = outHeight;\n\n    this.osdCanvas = new OffscreenCanvas(\n      this.osdReader!.header.config.fontWidth *\n        this.osdReader!.header.config.charWidth,\n      this.osdReader!.header.config.fontHeight *\n        this.osdReader!.header.config.charHeight\n    );\n    this.osdCtx = this.osdCanvas.getContext(\"2d\")!;\n\n    this.frameCanvas = new OffscreenCanvas(this.outWidth!, this.outHeight!);\n    this.frameCtx = this.frameCanvas.getContext(\"2d\")!;\n\n    this.lastOsdIndex = 0;\n\n    try {\n      await this.processor.process({\n        width: outWidth,\n        height: outHeight,\n      });\n\n      this.postMessage({\n        type: VideoWorkerShared.MessageType.COMPLETE,\n      });\n    } catch (e: any) {\n      this.postMessage({\n        type: VideoWorkerShared.MessageType.ERROR,\n        error: e,\n      });\n      throw e;\n    }\n  }\n\n  modifyFrame(frame: ImageBitmap, frameIndex: number): ImageBitmap {\n    const osdCanvas = this.osdCanvas!;\n    const osdCtx = this.osdCtx!;\n    const frameCanvas = this.frameCanvas!;\n    const frameCtx = this.frameCtx!;\n\n    frameCtx.fillStyle = \"black\";\n    frameCtx.fillRect(0, 0, frameCanvas.width, frameCanvas.height);\n    osdCtx.clearRect(0, 0, osdCanvas.width, osdCanvas.height);\n\n    let frameXOffset: number;\n    if (this.hd || this.wide) {\n      frameXOffset = (this.outWidth! - frame.width) / 2;\n    } else {\n      frameXOffset = 0;\n    }\n    frameCtx.drawImage(frame, frameXOffset, 0);\n\n    if (this.lastOsdIndex < this.osdReader!.frames.length - 1) {\n      const nextOsdIndex = this.lastOsdIndex + 1;\n      const nextOsdFrame = this.osdReader!.frames[nextOsdIndex];\n\n      if (frameIndex >= nextOsdFrame.frameNumber) {\n        this.lastOsdIndex = nextOsdIndex;\n      }\n    }\n\n    const osdFrame = this.osdReader!.frames[this.lastOsdIndex];\n    for (let y = 0; y < MAX_DISPLAY_Y; y++) {\n      for (let x = 0; x < MAX_DISPLAY_X; x++) {\n        const osdFrameIndex = y + MAX_DISPLAY_Y * x;\n        const osdFrameChar = osdFrame.frameData[osdFrameIndex];\n\n        let font: Font;\n        if (this.hd) {\n          font =\n            osdFrameChar < TILES_PER_PAGE\n              ? this.fontPack!.hd1\n              : this.fontPack!.hd2;\n        } else {\n          font =\n            osdFrameChar < TILES_PER_PAGE\n              ? this.fontPack!.sd1\n              : this.fontPack!.sd2;\n        }\n\n        osdCtx.drawImage(\n          font.getTile(osdFrameChar % TILES_PER_PAGE),\n          x * this.osdReader!.header.config.fontWidth,\n          y * this.osdReader!.header.config.fontHeight\n        );\n      }\n    }\n\n    // Try fit vertically, then try horizontally.\n    let osdScale: number;\n    if (\n      frameCanvas.height / osdCanvas.height <\n      frameCanvas.width / osdCanvas.width\n    ) {\n      osdScale = frameCanvas.height / osdCanvas.height;\n    } else {\n      osdScale = frameCanvas.width / osdCanvas.width;\n    }\n\n    const osdWidth = osdCanvas.width * osdScale;\n    const osdHeight = osdCanvas.height * osdScale;\n\n    const osdXOffset = (frameCanvas.width - osdWidth) / 2;\n    const osdYOffset = (frameCanvas.height - osdHeight) / 2;\n\n    frameCtx.drawImage(osdCanvas, osdXOffset, osdYOffset, osdWidth, osdHeight);\n\n    return frameCanvas.transferToImageBitmap();\n  }\n\n  progressInit(options: {\n    expectedFrames: number;\n  }) {\n    this.postMessage({\n      type: VideoWorkerShared.MessageType.PROGRESS_INIT,\n      ...options,\n    });\n  }\n\n  progressUpdate(options: {\n    framesDecoded?: number;\n    framesDecodedMissing?: number;\n    framesEncoded?: number;\n    preview?: ImageBitmap;\n    queuedForDecode?: number;\n    queuedForEncode?: number;\n    inEncoderQueue?: number;\n    inDecoderQueue?: number;\n  }) {\n    this.postMessage(\n      {\n        type: VideoWorkerShared.MessageType.PROGRESS_UPDATE,\n        ...options,\n      },\n      [...(options.preview ? [options.preview] : [])]\n    );\n  }\n\n  onMessage(event: MessageEvent<VideoWorkerShared.Message>) {\n    const message = event.data;\n    switch (message.type) {\n      case VideoWorkerShared.MessageType.START: {\n        this.start({\n          fontFiles: message.fontFiles,\n          osdFile: message.osdFile,\n          videoFile: message.videoFile,\n          outHandle: message.outHandle,\n        });\n        break;\n      }\n\n      default: {\n        throw new Error(\"Unknown message type received\");\n      }\n    }\n  }\n\n  private postMessage(message: VideoWorkerShared.Message, transfer?: Transferable[]) {\n    if (transfer) {\n      postMessage(message, transfer);\n    } else {\n      postMessage(message);\n    }\n  }\n}\n\nnew VideoWorker();\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [193], function() { return __webpack_require__(883); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"34d22fc3\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t883: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkwtfos_configurator\"] = self[\"webpackChunkwtfos_configurator\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(193).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["MessageType","DecoderError","message","name","Error","DecoderConfigureError","EncoderError","EncoderConfigureError","VideoWorkerShared","FileStreamReader","file","buffer","ArrayBuffer","bufferOffset","_offset","this","length","getNextBytes","bytes","byteBuffer","getNextUint8","byte","push","Uint8Array","decoder","TextDecoder","string","decode","getDataView","view","getUint8","getUint16","getUint32","getBigUint64","result","i","offset","bufferEndOffset","size","fillEndOffset","newBufferOffset","Math","floor","BUFFER_SIZE","newBufferEndOffset","ceil","slice","arrayBuffer","fillBuffer","DataView","byteLength","FileStreamWriter","stream","uint8Buffer","uint16Buffer","uint32Buffer","uint64Buffer","uint16View","uint32View","uint64View","_size","Uint16Array","Uint32Array","BigUint64Array","value","writeNextBytes","setUint16","setUint32","BigInt","setBigUint64","undefined","TextEncoder","encodeInto","getStream","write","Blob","seek","close","createWritable","truncate","getMp4Time","date","Date","startDate","getTime","parseBox","startOffset","getNextUint32","getNextString","type","console","debug","Number","getNextUint64","boxParsers","UrlBoxParser","UrnBoxParser","avc1","Avc1BoxParser","avcC","AvcCBoxParser","co64","Co64BoxParser","dinf","DinfBoxParser","dref","DrefBoxParser","ftyp","FtypBoxParser","hdlr","HdrlBoxParser","mdat","MdatBoxParser","mdhd","MdhdBoxParser","mdia","MdiaBoxParser","minf","MinfBoxParser","moov","MoovBoxParser","mvhd","MvhdBoxParser","stbl","StblBoxParser","stco","StcoBoxParser","stsc","StscBoxParser","stsd","StsdBoxParser","stss","StssBoxParser","stsz","StszBoxParser","stts","SttsBoxParser","tkhd","TkhdBoxParser","trak","TrakBoxParser","udta","UdtaBoxParser","vmhd","VmhdBoxParser","parser","warn","UnknownBoxParser","parse","BoxParser","header","getHeader","endOffset","boxes","getNextChildBox","box","diff","SimpleBoxParser","seekToEnd","FullBoxParser","version","flags","getFullBoxHeader","fullBoxHeader","majorBrand","minorVersion","compatibleBrands","getChildBoxes","childBoxes","creationTime","modificationTime","timescale","duration","rate","getNextUint16","volume","matrix","nextTrackId","trackId","layer","alternateGroup","width","height","languageBytes","language","String","fromCharCode","entryCount","entries","nextChild","dataReferenceIndex","horizontalResolution","verticalResolution","frameCount","compressorName","depth","configurationVersion","profileIndication","profileCompatibility","levelIndication","lengthSizeMinusOne","spsCount","sps","spsLength","spsData","ppsCount","pps","ppsLength","ppsData","sequenceParameterSets","pictureParameterSets","sampleNumbers","chunkOffsets","firstChunk","samplesPerChunk","sampleDescriptionIndex","sampleSizes","sampleCount","sampleDelta","handlerType","graphicsMode","opColor","location","writeBox","writer","UrlBoxWriter","UrnBoxWriter","Avc1BoxWriter","AvcCBoxWriter","DinfBoxWriter","DrefBoxWriter","FtypBoxWriter","HdlrBoxWriter","MdhdBoxWriter","MdiaBoxWriter","MinfBoxWriter","MoovBoxWriter","MvhdBoxWriter","StblBoxWriter","StcoBoxWriter","StscBoxWriter","StsdBoxWriter","StssBoxWriter","StszBoxWriter","SttsBoxWriter","TkhdBoxWriter","TrakBoxWriter","VmhdBoxWriter","BoxWriter","writeNextUint32","writeNextString","writeContents","FullBoxWriter","writeNextUint8","compatibleBrand","sequenceParameterSet","writeNextUint16","skip","entry","color","chunkOffset","sampleSize","sampleNumber","MdatBoxStreamWriter","sizeOffset","opened","closed","writeNextUint64","MP4Parser","eof","sampleOffset","isSampleSync","data","sync","includes","MP4Writer","syncSamples","displaySize","frameRate","open","avcCStruct","byteOffset","options","framerate","getMvhdBox","getTrakBox","getTkhdBox","getMdiaBox","nowMp4Time","getMinfBox","getMdhdBox","getStblBox","getDinfBox","dataStartOffset","avcCBoxToDescription","avcCBox","StreamDataView","setNextUint8","setNextUint16","j","getBuffer","Processor","encoder","inMp4","outMp4","expectedFrames","framesDecoded","framesDecodedMissing","framesEncoded","queuedForDecode","queuedForEncode","modifyFrame","progressInit","progressUpdate","processResolve","processReject","progressUpdateIntervalHandle","decodedFrames","encodedFrames","sendProgressUpdate","bind","outHandle","reset","Promise","resolve","reject","avc1box","codec","toString","padStart","configure","codedWidth","codedHeight","description","optimizeForLatency","e","bitrate","latencyMode","scalabilityMode","setDisplaySize","setFramerate","self","setInterval","processSamples","VideoEncoder","output","handleEncodedFrame","error","handleEncoderError","VideoDecoder","handleDecodedFrame","handleDecoderError","clearInterval","lastSampleIndex","sampleChunks","sampleIndex","getSample","sample","index","chunk","image","encodedChunk","EncodedVideoChunk","timestamp","flush","Object","values","modifiedFrame","frame","VideoFrame","preview","encode","keyFrame","writeSample","createImageBitmap","metadata","copyTo","setAvcC","decoderConfig","inDecoderQueue","decodeQueueSize","inEncoderQueue","encodeQueueSize","TILES_PER_PAGE","Font","tiles","isHd","tileWidth","tileHeight","tileIndex","pixData","Uint8ClampedArray","imageData","ImageData","imageBitmap","files","fromFile","sd1","sd2","hd1","hd2","OsdReader","frames","magic","config","charWidth","charHeight","fontWidth","fontHeight","xOffset","yOffset","fontVariant","getOffset","frameNumber","frameSize","frameData","setOffset","RangeError","VideoWorker","processor","fontPack","osdReader","lastOsdIndex","wide","hd","outWidth","outHeight","osdCanvas","osdCtx","frameCanvas","frameCtx","addEventListener","onMessage","osdFile","fromFiles","fontFiles","videoFile","OffscreenCanvas","getContext","process","postMessage","frameIndex","frameXOffset","fillStyle","fillRect","clearRect","drawImage","nextOsdIndex","osdScale","osdFrame","y","x","osdFrameIndex","osdFrameChar","font","getTile","osdWidth","osdHeight","osdXOffset","osdYOffset","transferToImageBitmap","event","start","transfer","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","keys","every","key","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","get","f","chunkId","all","reduce","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","moreModules","runtime","pop","next","then"],"sourceRoot":""}
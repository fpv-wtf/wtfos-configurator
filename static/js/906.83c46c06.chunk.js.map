{"version":3,"file":"static/js/906.83c46c06.chunk.js","mappings":"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","sources":["osd-overlay/shared.ts","osd-overlay/mp4/io/reader.ts","osd-overlay/mp4/io/writer.ts","osd-overlay/mp4/utils.ts","osd-overlay/mp4/parsers.ts","osd-overlay/mp4/writers.ts","osd-overlay/mp4/index.ts","osd-overlay/processor.ts","osd-overlay/fonts.ts","osd-overlay/osd.ts","osd-overlay/srt.ts","osd-overlay/worker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import { FontPackFiles } from \"./fonts\";\n\nnamespace VideoWorkerShared {\n  export const enum MessageType {\n    COMPLETE,\n    ERROR,\n    PROGRESS_INIT,\n    PROGRESS_UPDATE,\n    START,\n  }\n\n  export interface CompleteMessage {\n    type: MessageType.COMPLETE;\n  }\n\n  export interface ErrorMessage {\n    type: MessageType.ERROR;\n    error: Error;\n  }\n\n  export interface ProgressInitMessage {\n    type: MessageType.PROGRESS_INIT;\n\n    expectedFrames: number;\n  }\n\n  export interface ProgressUpdateMessage {\n    type: MessageType.PROGRESS_UPDATE;\n\n    framesDecoded?: number;\n    framesDecodedMissing?: number;\n    framesEncoded?: number;\n    inDecoderQueue?: number;\n    inEncoderQueue?: number;\n    preview?: ImageBitmap;\n    queuedForDecode?: number;\n    queuedForEncode?: number;\n  }\n\n  export interface StartMessage {\n    type: MessageType.START;\n\n    chromaKey: boolean;\n    chromaKeyColor: string;\n\n    fontFiles: FontPackFiles,\n    osdFile: File;\n    srtFile: File;\n    outHandle: FileSystemFileHandle;\n    videoFile: File;\n  }\n\n  export type Message =\n    | CompleteMessage\n    | ErrorMessage\n    | ProgressInitMessage\n    | ProgressUpdateMessage\n    | StartMessage;\n\n  export class DecoderError extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = \"DecoderError\";\n    }\n  }\n\n  export class DecoderConfigureError extends DecoderError {\n    constructor(message: string) {\n      super(message);\n      this.name = \"DecoderConfigureError\";\n    }\n  }\n\n  export class EncoderError extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = \"EncoderError\";\n    }\n  }\n\n  export class EncoderConfigureError extends EncoderError {\n    constructor(message: string) {\n      super(message);\n      this.name = \"EncoderConfigureError\";\n    }\n  }\n\n}\n\nexport default VideoWorkerShared;\n","export class FileStreamReader {\n  private static readonly BUFFER_SIZE = 1024 * 1024 * 8; // 8MB\n\n  private file: File;\n\n  private buffer = new ArrayBuffer(0);\n  private bufferOffset = 0;\n  private _offset = 0;\n\n  constructor(file: File) {\n    this.file = file;\n  }\n\n  async getNextString(length?: number): Promise<string> {\n    let bytes: Uint8Array;\n\n    if (length) {\n      bytes = await this.getNextBytes(length);\n    } else {\n      const byteBuffer = [];\n      let byte: number;\n      while ((byte = await this.getNextUint8()) !== 0) {\n        byteBuffer.push(byte);\n      }\n\n      bytes = new Uint8Array(byteBuffer);\n    }\n\n    const decoder = new TextDecoder();\n    const string = decoder.decode(bytes);\n    return string;\n  }\n\n  async getNextUint8(): Promise<number> {\n    const view = await this.getDataView(1);\n    return view.getUint8(0);\n  }\n\n  async getNextUint16(): Promise<number> {\n    const view = await this.getDataView(2);\n    return view.getUint16(0);\n  }\n\n  async getNextUint32(): Promise<number> {\n    const view = await this.getDataView(4);\n    return view.getUint32(0);\n  }\n\n  async getNextUint64(): Promise<bigint> {\n    const view = await this.getDataView(8);\n    return view.getBigUint64(0);\n  }\n\n  async getNextBytes(length: number): Promise<Uint8Array> {\n    const view = await this.getDataView(length);\n    const result = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n      result[i] = view.getUint8(i);\n    }\n\n    return result;\n  }\n\n  seek(offset: number) {\n    this._offset = offset;\n    if (\n      this._offset < this.bufferOffset ||\n      this._offset > this.bufferEndOffset\n    ) {\n      this.buffer = new ArrayBuffer(0);\n      this.bufferOffset = this._offset;\n    }\n  }\n\n  skip(length: number) {\n    this._offset += length;\n  }\n\n  get eof() {\n    return this.offset >= this.file.size;\n  }\n\n  get offset() {\n    return this._offset;\n  }\n\n  get size() {\n    return this.file.size;\n  }\n\n  private async fillBuffer(length: number) {\n    const fillEndOffset = this.offset + length;\n\n    if (fillEndOffset > this.bufferEndOffset) {\n      const newBufferOffset =\n        Math.floor(this.offset / FileStreamReader.BUFFER_SIZE) *\n        FileStreamReader.BUFFER_SIZE;\n      const newBufferEndOffset =\n        Math.ceil(fillEndOffset / FileStreamReader.BUFFER_SIZE) *\n        FileStreamReader.BUFFER_SIZE;\n\n      this.buffer = await this.file\n        .slice(newBufferOffset, newBufferEndOffset)\n        .arrayBuffer();\n      this.bufferOffset = newBufferOffset;\n    }\n  }\n\n  private async getDataView(length: number): Promise<DataView> {\n    await this.fillBuffer(length);\n\n    const result = new DataView(\n      this.buffer,\n      this.offset - this.bufferOffset,\n      length\n    );\n    this._offset += length;\n    return result;\n  }\n\n  private get bufferEndOffset() {\n    return this.bufferOffset + this.buffer.byteLength;\n  }\n}\n","export class FileStreamWriter {\n  private readonly file: FileSystemFileHandle;\n  private stream?: FileSystemWritableFileStream;\n\n  private buffer?: ArrayBuffer;\n\n  private uint8Buffer?: Uint8Array;\n  private uint16Buffer?: Uint16Array;\n  private uint32Buffer?: Uint32Array;\n  private uint64Buffer?: BigUint64Array;\n\n  private uint16View?: DataView;\n  private uint32View?: DataView;\n  private uint64View?: DataView;\n\n  private _offset = 0;\n  private _size = 0;\n\n  constructor(file: FileSystemFileHandle) {\n    this.file = file;\n\n    this.buffer = new ArrayBuffer(8);\n\n    this.uint8Buffer = new Uint8Array(this.buffer, 0, 1);\n    this.uint16Buffer = new Uint16Array(this.buffer, 0, 1);\n    this.uint32Buffer = new Uint32Array(this.buffer, 0, 1);\n    this.uint64Buffer = new BigUint64Array(this.buffer, 0, 1);\n\n    this.uint16View = new DataView(this.buffer, 0, 2);\n    this.uint32View = new DataView(this.buffer, 0, 4);\n    this.uint64View = new DataView(this.buffer, 0, 8);\n  }\n\n  async writeNextUint8(value: number): Promise<void> {\n    this.uint8Buffer![0] = value;\n\n    await this.writeNextBytes(this.uint8Buffer!);\n  }\n\n  async writeNextUint16(value: number): Promise<void> {\n    this.uint16View!.setUint16(0, value, false);\n    await this.writeNextBytes(this.uint16Buffer!);\n  }\n\n  async writeNextUint32(value: number): Promise<void> {\n    this.uint32View!.setUint32(0, value, false);\n    await this.writeNextBytes(this.uint32Buffer!);\n  }\n\n  async writeNextUint64(value: number | bigint): Promise<void> {\n    if (typeof value === \"number\") {\n      value = BigInt(value);\n    }\n\n    this.uint64View!.setBigUint64(0, value, false);\n    await this.writeNextBytes(this.uint64Buffer!);\n  }\n\n  async writeNextString(value: string, length?: number): Promise<void> {\n    const buffer = new Uint8Array(\n      length !== undefined ? length : value.length + 1\n    );\n\n    const encoder = new TextEncoder();\n    encoder.encodeInto(value, buffer);\n\n    await this.writeNextBytes(buffer);\n  }\n\n  async writeNextBytes(bytes: BufferSource | Blob): Promise<void> {\n    const stream = await this.getStream();\n    await stream.write(bytes);\n\n    const byteLength = bytes instanceof Blob ? bytes.size : bytes.byteLength;\n    this._offset += byteLength;\n    this._size += byteLength;\n  }\n\n  async skip(length: number) {\n    await this.seek(this.offset + length);\n  }\n\n  async seek(offset: number) {\n    const stream = await this.getStream();\n    await stream.seek(offset);\n    this._offset = offset;\n  }\n\n  async close() {\n    const stream = await this.getStream();\n    await stream.close();\n    this.stream = undefined;\n  }\n\n  private async getStream(): Promise<FileSystemWritableFileStream> {\n    if (!this.stream) {\n      this.stream = await this.file.createWritable();\n      await this.stream.truncate(0);\n\n      this._size = 0;\n      this._offset = 0;\n    }\n\n    return this.stream;\n  }\n\n  get offset(): number {\n    return this._offset;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n}\n","/**\n * Convert a date to a time in seconds since 1904-01-01T00:00:00Z, as used by\n * MP4 files.\n * @param date Date to convert. If not provided, the current date is used.\n * @returns Number of seconds since 1904-01-01T00:00:00Z\n */\nexport function getMp4Time(date?: Date): number {\n  if (date === undefined) {\n    date = new Date();\n  }\n\n  const startDate = new Date(\"1904-01-01T00:00:00Z\");\n  const diffSeconds = Math.floor(\n    (date.getTime() - startDate.getTime()) / 1000\n  );\n\n  return diffSeconds;\n}\n","import { FileStreamReader } from \"./io/reader\";\nimport {\n  Avc1Box,\n  AvcCBox,\n  BaseBox,\n  BaseFullBox,\n  Box,\n  BoxHeader,\n  BoxType,\n  Co64Box,\n  DinfBox,\n  DrefBox,\n  FtypBox,\n  FullBoxHeader,\n  HdlrBox,\n  MdatBox,\n  MdhdBox,\n  MdiaBox,\n  MinfBox,\n  MoovBox,\n  MvhdBox,\n  SampleEntryBox,\n  StblBox,\n  StcoBox,\n  StscBox,\n  StsdBox,\n  StssBox,\n  StszBox,\n  SttsBox,\n  TkhdBox,\n  TrakBox,\n  UdtaBox,\n  UnknownBox,\n  UrlBox,\n  UrnBox,\n  VmhdBox,\n  CttsBox,\n} from \"./types\";\n\nexport async function parseBox(stream: FileStreamReader): Promise<Box> {\n  const startOffset = stream.offset;\n\n  let size = await stream.getNextUint32();\n  const type = await stream.getNextString(4);\n\n  if (size === 0) {\n    size = stream.size - startOffset;\n    console.debug(\n      `${type} box has size 0, must continue until end of file: ${size}`\n    );\n  } else if (size === 1) {\n    // Not actually 64-bits but 9007TB is enough for any one box, I'm sure.\n    size = Number(await stream.getNextUint64());\n    console.debug(`${type} box has big size: ${size}`);\n  }\n\n  const boxParsers: Record<\n    string,\n    new (\n      stream: FileStreamReader,\n      startOffset: number,\n      size: number,\n      type: string\n    ) => BoxParser<Box>\n  > = {\n    \"url \": UrlBoxParser,\n    \"urn \": UrnBoxParser,\n    avc1: Avc1BoxParser,\n    avcC: AvcCBoxParser,\n    co64: Co64BoxParser,\n    dinf: DinfBoxParser,\n    dref: DrefBoxParser,\n    ftyp: FtypBoxParser,\n    hdlr: HdrlBoxParser,\n    mdat: MdatBoxParser,\n    mdhd: MdhdBoxParser,\n    mdia: MdiaBoxParser,\n    minf: MinfBoxParser,\n    moov: MoovBoxParser,\n    mvhd: MvhdBoxParser,\n    stbl: StblBoxParser,\n    stco: StcoBoxParser,\n    stsc: StscBoxParser,\n    stsd: StsdBoxParser,\n    stss: StssBoxParser,\n    stsz: StszBoxParser,\n    stts: SttsBoxParser,\n    tkhd: TkhdBoxParser,\n    trak: TrakBoxParser,\n    udta: UdtaBoxParser,\n    vmhd: VmhdBoxParser,\n    ctts: CttsBoxParser,\n  };\n\n  let parser: BoxParser<Box>;\n  if (boxParsers[type]) {\n    parser = new boxParsers[type](stream, startOffset, size, type);\n  } else {\n    console.warn(\n      `No parser available for %c${type}`,\n      \"text-decoration: underline\"\n    );\n    parser = new UnknownBoxParser(stream, startOffset, size, type);\n  }\n\n  return await parser.parse();\n}\n\nabstract class BoxParser<T extends BaseBox> {\n  protected readonly stream: FileStreamReader;\n  protected readonly size: number;\n  protected readonly type: string;\n  protected readonly startOffset: number;\n\n  protected readonly header: BoxHeader;\n\n  constructor(\n    stream: FileStreamReader,\n    startOffset: number,\n    size: number,\n    type: string\n  ) {\n    this.stream = stream;\n    this.startOffset = startOffset;\n    this.size = size;\n    this.type = type;\n\n    this.header = this.getHeader();\n  }\n\n  private getHeader(): BoxHeader {\n    const endOffset = this.startOffset + this.size;\n\n    return {\n      size: this.size,\n      type: this.type,\n\n      startOffset: this.startOffset,\n      endOffset,\n    };\n  }\n\n  protected async getChildBoxes(): Promise<Partial<Record<BoxType, Box[]>>> {\n    const boxes: Partial<Record<BoxType, Box[]>> = {};\n\n    while (this.stream.offset < this.header.endOffset) {\n      const box = await this.getNextChildBox();\n\n      if (box.type === \"unknown\") {\n        console.warn(\n          `Child box %c${box.header!.type}%c in %c${\n            this.type\n          }%c is unknown, ignoring.`,\n          \"text-decoration: underline\",\n          \"text-decoration: none\",\n          \"text-decoration: underline\",\n          \"text-decoration: none\"\n        );\n      }\n\n      if (!(box.type in boxes)) {\n        boxes[box.type] = [];\n      }\n\n      boxes[box.type]!.push(box);\n    }\n\n    return boxes;\n  }\n\n  protected async getNextChildBox(): Promise<Box> {\n    return await parseBox(this.stream);\n  }\n\n  protected seekToEnd(): void {\n    if (this.stream.offset !== this.header.endOffset) {\n      const diff = this.header.endOffset - this.stream.offset;\n      console.warn(\n        `Box %c${this.header.type}%c was not fully parsed! Stopped ${diff}B early.`,\n        \"text-decoration: underline\",\n        \"text-decoration: none\",\n        this.header\n      );\n    }\n\n    this.stream.seek(this.header.endOffset);\n  }\n\n  abstract parse(): Promise<T>;\n}\n\nabstract class SimpleBoxParser<T extends BaseBox> extends BoxParser<T> {\n  async parse(): Promise<T> {\n    const box = await this.parseBox(this.header);\n    this.seekToEnd();\n    return box;\n  }\n\n  protected abstract parseBox(header: BoxHeader): Promise<T>;\n}\n\nabstract class FullBoxParser<T extends BaseFullBox> extends BoxParser<T> {\n  protected async getFullBoxHeader() {\n    const version = await this.stream.getNextUint8();\n    const flags =\n      ((await this.stream.getNextUint8()) << 16) |\n      ((await this.stream.getNextUint8()) << 8) |\n      (await this.stream.getNextUint8());\n\n    return {\n      version,\n      flags,\n    };\n  }\n\n  async parse(): Promise<T> {\n    const fullBoxHeader = await this.getFullBoxHeader();\n    const box = await this.parseBox(this.header, fullBoxHeader);\n    this.seekToEnd();\n    return box;\n  }\n\n  protected abstract parseBox(\n    header: BoxHeader,\n    fullHeader: FullBoxHeader\n  ): Promise<T>;\n}\n\nclass FtypBoxParser extends SimpleBoxParser<FtypBox> {\n  async parseBox(header: BoxHeader): Promise<FtypBox> {\n    const majorBrand = await this.stream.getNextString(4);\n    const minorVersion = await this.stream.getNextUint32();\n    const compatibleBrands = [];\n\n    while (this.stream.offset < header.endOffset) {\n      compatibleBrands.push(await this.stream.getNextString(4));\n    }\n\n    return {\n      type: \"ftyp\",\n      header,\n      majorBrand,\n      minorVersion,\n      compatibleBrands,\n    };\n  }\n}\n\nclass MdatBoxParser extends SimpleBoxParser<MdatBox> {\n  async parseBox(header: BoxHeader): Promise<MdatBox> {\n    this.stream.seek(this.header.endOffset);\n\n    return {\n      type: \"mdat\",\n      header,\n    };\n  }\n}\n\nclass MoovBoxParser extends SimpleBoxParser<MoovBox> {\n  async parseBox(header: BoxHeader): Promise<MoovBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      type: \"moov\",\n      header,\n      mvhd: childBoxes.mvhd![0] as MvhdBox,\n      trak: childBoxes.trak as TrakBox[],\n    };\n  }\n}\n\nclass MvhdBoxParser extends FullBoxParser<MvhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<MvhdBox> {\n    if (fullBoxHeader.version === 1) {\n      throw new Error(\"Version 1 not supported\");\n    }\n\n    const creationTime = await this.stream.getNextUint32();\n    const modificationTime = await this.stream.getNextUint32();\n    const timescale = await this.stream.getNextUint32();\n    const duration = await this.stream.getNextUint32();\n    const rate = await this.stream.getNextUint32();\n    const volume = await this.stream.getNextUint16();\n\n    // Reserved.\n    await this.stream.getNextUint16();\n    await this.stream.getNextUint32();\n    await this.stream.getNextUint32();\n\n    const matrix = [];\n    for (let i = 0; i < 9; i++) {\n      matrix.push(await this.stream.getNextUint32());\n    }\n\n    // Predefined.\n    for (let i = 0; i < 6; i++) {\n      await this.stream.getNextUint32();\n    }\n\n    const nextTrackId = await this.stream.getNextUint32();\n\n    return {\n      header,\n      type: \"mvhd\",\n      fullBoxHeader,\n      creationTime,\n      modificationTime,\n      timescale,\n      duration,\n      rate,\n      volume,\n      matrix,\n      nextTrackId,\n    };\n  }\n}\n\nclass TrakBoxParser extends SimpleBoxParser<TrakBox> {\n  async parseBox(header: BoxHeader): Promise<TrakBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"trak\",\n      tkhd: childBoxes.tkhd![0] as TkhdBox,\n      mdia: childBoxes.mdia![0] as MdiaBox,\n    };\n  }\n}\n\nclass TkhdBoxParser extends FullBoxParser<TkhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<TkhdBox> {\n    if (fullBoxHeader.version === 1) {\n      throw new Error(\"Version 1 not supported\");\n    }\n\n    const creationTime = await this.stream.getNextUint32();\n    const modificationTime = await this.stream.getNextUint32();\n    const trackId = await this.stream.getNextUint32();\n    await this.stream.getNextUint32(); // Reserved\n    const duration = await this.stream.getNextUint32();\n\n    await this.stream.getNextUint32(); // Reserved\n    await this.stream.getNextUint32(); // Reserved\n\n    const layer = await this.stream.getNextUint16();\n    const alternateGroup = await this.stream.getNextUint16();\n    const volume = await this.stream.getNextUint16();\n\n    await this.stream.getNextUint16(); // Reserved.\n\n    const matrix = [];\n    for (let i = 0; i < 9; i++) {\n      matrix.push(await this.stream.getNextUint32());\n    }\n\n    const width = (await this.stream.getNextUint32()) >> 16;\n    const height = (await this.stream.getNextUint32()) >> 16;\n\n    return {\n      header,\n      type: \"tkhd\",\n      fullBoxHeader,\n      creationTime,\n      modificationTime,\n      trackId,\n      duration,\n      layer,\n      alternateGroup,\n      volume,\n      matrix,\n      width,\n      height,\n    };\n  }\n}\n\nclass MdiaBoxParser extends SimpleBoxParser<MdiaBox> {\n  async parseBox(header: BoxHeader): Promise<MdiaBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"mdia\",\n      mdhd: childBoxes.mdhd![0] as MdhdBox,\n      minf: childBoxes.minf![0] as MinfBox,\n      hdlr: childBoxes.hdlr![0] as HdlrBox,\n    };\n  }\n}\n\nclass MdhdBoxParser extends FullBoxParser<MdhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<MdhdBox> {\n    if (fullBoxHeader.version === 1) {\n      throw new Error(\"Version 1 not supported\");\n    }\n\n    const creationTime = await this.stream.getNextUint32();\n    const modificationTime = await this.stream.getNextUint32();\n    const timescale = await this.stream.getNextUint32();\n    const duration = await this.stream.getNextUint32();\n\n    const languageBytes = await this.stream.getNextUint16();\n    let language = \"\";\n    for (let i = 0; i < 3; i++) {\n      language += String.fromCharCode(0x60 + ((languageBytes >> (2 - i) * 5) & 0x1f));\n    }\n\n    await this.stream.getNextUint16(); // Reserved.\n\n    return {\n      header,\n      type: \"mdhd\",\n      fullBoxHeader,\n      creationTime,\n      modificationTime,\n      timescale,\n      duration,\n      language,\n    };\n  }\n}\n\nclass MinfBoxParser extends SimpleBoxParser<MinfBox> {\n  async parseBox(header: BoxHeader): Promise<MinfBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"minf\",\n      vmhd: \"vmhd\" in childBoxes ? (childBoxes.vmhd![0] as VmhdBox) : undefined,\n      stbl: childBoxes.stbl![0] as StblBox,\n      dinf: childBoxes.dinf![0] as DinfBox,\n    };\n  }\n}\n\nclass StblBoxParser extends SimpleBoxParser<StblBox> {\n  async parseBox(header: BoxHeader): Promise<StblBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"stbl\",\n      stco: childBoxes.stco?.[0] as StcoBox,\n      co64: childBoxes.co64?.[0] as Co64Box,\n      stsc: childBoxes.stsc![0] as StscBox,\n      stsd: childBoxes.stsd![0] as StsdBox,\n      stss: childBoxes.stss![0] as StssBox,\n      stsz: childBoxes.stsz![0] as StszBox,\n      stts: childBoxes.stts![0] as SttsBox,\n      ctts: childBoxes.ctts ? childBoxes.ctts![0] as CttsBox : undefined,\n    };\n  }\n}\n\nclass StsdBoxParser extends FullBoxParser<StsdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StsdBox> {\n    const entryCount = await this.stream.getNextUint32();\n\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      const nextChild = (await this.getNextChildBox()) as SampleEntryBox;\n      entries.push(nextChild);\n    }\n\n    return {\n      header,\n      type: \"stsd\",\n      fullBoxHeader,\n      entries,\n    };\n  }\n}\n\nclass Avc1BoxParser extends SimpleBoxParser<Avc1Box> {\n  async parseBox(header: BoxHeader): Promise<Avc1Box> {\n    // Reserved\n    for (let i = 0; i < 6; i++) {\n      await this.stream.getNextUint8();\n    }\n\n    const dataReferenceIndex = await this.stream.getNextUint16();\n\n    // Technically from VisualSampleEntry but...\n    for (let i = 0; i < 2; i++) {\n      await this.stream.getNextUint16(); // Reserved\n    }\n    for (let i = 0; i < 3; i++) {\n      await this.stream.getNextUint32(); // Reserved\n    }\n\n    const width = await this.stream.getNextUint16();\n    const height = await this.stream.getNextUint16();\n    const horizontalResolution = await this.stream.getNextUint32();\n    const verticalResolution = await this.stream.getNextUint32();\n\n    await this.stream.getNextUint32(); // Reserved\n\n    const frameCount = await this.stream.getNextUint16();\n    const compressorName = await this.stream.getNextString(32);\n    const depth = await this.stream.getNextUint16();\n\n    await this.stream.getNextUint16(); // Reserved\n\n    const avcC = (await this.getNextChildBox()) as AvcCBox;\n\n    return {\n      header,\n      type: \"avc1\",\n      avcC,\n      compressorName,\n      dataReferenceIndex,\n      depth,\n      frameCount,\n      height,\n      horizontalResolution,\n      verticalResolution,\n      width,\n    };\n  }\n}\n\nclass AvcCBoxParser extends SimpleBoxParser<AvcCBox> {\n  async parseBox(header: BoxHeader): Promise<AvcCBox> {\n    const configurationVersion = await this.stream.getNextUint8();\n    const profileIndication = await this.stream.getNextUint8();\n    const profileCompatibility = await this.stream.getNextUint8();\n    const levelIndication = await this.stream.getNextUint8();\n    const lengthSizeMinusOne = (await this.stream.getNextUint8()) & 0x3;\n\n    const spsCount = (await this.stream.getNextUint8()) & 0x1f;\n    const sps = [];\n    for (let i = 0; i < spsCount; i++) {\n      const spsLength = await this.stream.getNextUint16();\n      const spsData = await this.stream.getNextBytes(spsLength);\n      sps.push(spsData);\n    }\n\n    const ppsCount = await this.stream.getNextUint8();\n    const pps = [];\n    for (let i = 0; i < ppsCount; i++) {\n      const ppsLength = await this.stream.getNextUint16();\n      const ppsData = await this.stream.getNextBytes(ppsLength);\n      pps.push(ppsData);\n    }\n\n    return {\n      header,\n      type: \"avcC\",\n      configurationVersion,\n      profileIndication,\n      profileCompatibility,\n      levelIndication,\n      lengthSizeMinusOne,\n      sequenceParameterSets: sps,\n      pictureParameterSets: pps,\n    };\n  }\n}\n\nclass StssBoxParser extends FullBoxParser<StssBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StssBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const sampleNumbers = [];\n    for (let i = 0; i < entryCount; i++) {\n      sampleNumbers.push(await this.stream.getNextUint32());\n    }\n\n    return {\n      header,\n      type: \"stss\",\n      fullBoxHeader,\n      sampleNumbers,\n    };\n  }\n}\n\nclass StcoBoxParser extends FullBoxParser<StcoBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StcoBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const chunkOffsets = [];\n    for (let i = 0; i < entryCount; i++) {\n      chunkOffsets.push(await this.stream.getNextUint32());\n    }\n\n    return {\n      header,\n      type: \"stco\",\n      fullBoxHeader,\n      chunkOffsets,\n    };\n  }\n}\n\nclass Co64BoxParser extends FullBoxParser<Co64Box> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<Co64Box> {\n    const entryCount = await this.stream.getNextUint32();\n    const chunkOffsets = [];\n    for (let i = 0; i < entryCount; i++) {\n      chunkOffsets.push(Number(await this.stream.getNextUint64()));\n    }\n\n    return {\n      header,\n      type: \"co64\",\n      fullBoxHeader,\n      chunkOffsets,\n    };\n  }\n}\n\nclass StscBoxParser extends FullBoxParser<StscBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StscBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      entries.push({\n        firstChunk: await this.stream.getNextUint32(),\n        samplesPerChunk: await this.stream.getNextUint32(),\n        sampleDescriptionIndex: await this.stream.getNextUint32(),\n      });\n    }\n\n    return {\n      header,\n      type: \"stsc\",\n      fullBoxHeader,\n      entries,\n    };\n  }\n}\n\nclass StszBoxParser extends FullBoxParser<StszBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StszBox> {\n    let sampleSizes = [await this.stream.getNextUint32()];\n    const sampleCount = await this.stream.getNextUint32();\n\n    // If sample size is 0, then we have a table of sample sizes, otherwise\n    // all samples are the same size.\n    if (sampleSizes[0] === 0) {\n      sampleSizes = [];\n      for (let i = 0; i < sampleCount; i++) {\n        sampleSizes.push(await this.stream.getNextUint32());\n      }\n    }\n\n    return {\n      header,\n      type: \"stsz\",\n      fullBoxHeader,\n      sampleSizes,\n      sampleCount,\n    };\n  }\n}\n\nclass SttsBoxParser extends FullBoxParser<SttsBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<SttsBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      entries.push({\n        sampleCount: await this.stream.getNextUint32(),\n        sampleDelta: await this.stream.getNextUint32(),\n      });\n    }\n\n    return {\n      header,\n      type: \"stts\",\n      fullBoxHeader,\n      entries,\n    };\n  }\n}\n\nclass UdtaBoxParser extends SimpleBoxParser<UdtaBox> {\n  async parseBox(header: BoxHeader): Promise<UdtaBox> {\n    // TODO: Not fully parsed.\n    await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"udta\",\n    };\n  }\n}\n\nclass HdrlBoxParser extends FullBoxParser<HdlrBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<HdlrBox> {\n    await this.stream.getNextUint32(); // Predefined\n\n    const handlerType = await this.stream.getNextString(4);\n\n    for (let i = 0; i < 3; i++) {\n      await this.stream.getNextUint32(); // Reserved\n    }\n\n    const name = await this.stream.getNextString();\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"hdlr\",\n      handlerType,\n      name,\n    };\n  }\n}\n\nclass VmhdBoxParser extends FullBoxParser<VmhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<VmhdBox> {\n    const graphicsMode = await this.stream.getNextUint16();\n    const opColor = [\n      await this.stream.getNextUint16(),\n      await this.stream.getNextUint16(),\n      await this.stream.getNextUint16(),\n    ];\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"vmhd\",\n      graphicsMode,\n      opColor,\n    };\n  }\n}\n\nclass CttsBoxParser extends FullBoxParser<CttsBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<CttsBox> {\n    const sampleCount = await this.stream.getNextUint32();\n    const sampleCounts = [];\n    const sampleOffsets = [];\n\n    for (let i = 0; i < sampleCount; i++) {\n      sampleCounts.push(await this.stream.getNextUint32());\n      sampleOffsets.push(await this.stream.getNextUint32());\n    }\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"ctts\",\n      sampleCounts,\n      sampleOffsets,\n    };\n  }\n}\n\nclass DrefBoxParser extends FullBoxParser<DrefBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<DrefBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      entries.push((await this.getNextChildBox()) as UrlBox | UrnBox);\n    }\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"dref\",\n      entries,\n    };\n  }\n}\n\nclass DinfBoxParser extends SimpleBoxParser<DinfBox> {\n  async parseBox(header: BoxHeader): Promise<DinfBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"dinf\",\n      dref: childBoxes.dref![0] as DrefBox,\n    };\n  }\n}\n\nclass UrnBoxParser extends FullBoxParser<UrnBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<UrnBox> {\n    let name: string = \"\";\n    let location: string = \"\";\n    if (fullBoxHeader.flags !== 1) {\n      name = await this.stream.getNextString();\n      location = await this.stream.getNextString();\n    }\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"urn \",\n      name,\n      location,\n    };\n  }\n}\n\nclass UrlBoxParser extends FullBoxParser<UrlBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<UrlBox> {\n    let location: string = \"\";\n    if (fullBoxHeader.flags !== 1) {\n      location = await this.stream.getNextString();\n    }\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"url \",\n      location,\n    };\n  }\n}\n\nclass UnknownBoxParser extends SimpleBoxParser<UnknownBox> {\n  async parseBox(header: BoxHeader): Promise<UnknownBox> {\n    this.stream.seek(this.header.endOffset);\n\n    return {\n      header,\n      type: \"unknown\",\n    };\n  }\n}\n","import { FileStreamWriter } from \"./io/writer\";\nimport {\n  Avc1Box,\n  AvcCBox,\n  BaseBox,\n  BaseFullBox,\n  Box,\n  DinfBox,\n  DrefBox,\n  FtypBox,\n  HdlrBox,\n  MdhdBox,\n  MdiaBox,\n  MinfBox,\n  MoovBox,\n  MvhdBox,\n  StblBox,\n  StcoBox,\n  StscBox,\n  StsdBox,\n  StssBox,\n  StszBox,\n  SttsBox,\n  TkhdBox,\n  TrakBox,\n  UrlBox,\n  UrnBox,\n  VmhdBox,\n} from \"./types\";\n\nexport async function writeBox(\n  stream: FileStreamWriter,\n  box: Box\n): Promise<void> {\n  const boxWriters: Record<\n    string,\n    new (writer: FileStreamWriter) => BoxWriter<Box>\n  > = {\n    \"url \": UrlBoxWriter,\n    \"urn \": UrnBoxWriter,\n    avc1: Avc1BoxWriter,\n    avcC: AvcCBoxWriter,\n    dinf: DinfBoxWriter,\n    dref: DrefBoxWriter,\n    ftyp: FtypBoxWriter,\n    hdlr: HdlrBoxWriter,\n    mdhd: MdhdBoxWriter,\n    mdia: MdiaBoxWriter,\n    minf: MinfBoxWriter,\n    moov: MoovBoxWriter,\n    mvhd: MvhdBoxWriter,\n    stbl: StblBoxWriter,\n    stco: StcoBoxWriter,\n    stsc: StscBoxWriter,\n    stsd: StsdBoxWriter,\n    stss: StssBoxWriter,\n    stsz: StszBoxWriter,\n    stts: SttsBoxWriter,\n    tkhd: TkhdBoxWriter,\n    trak: TrakBoxWriter,\n    vmhd: VmhdBoxWriter,\n  };\n\n  let writer = boxWriters[box.type];\n  if (!writer) {\n    console.warn(\n      `No writer available for %c${box.type}, not writing.`,\n      \"text-decoration: underline\"\n    );\n  }\n\n  await new writer(stream).write(box);\n}\n\nabstract class BoxWriter<T extends BaseBox> {\n  constructor(protected readonly stream: FileStreamWriter) {}\n\n  async write(box: T): Promise<void> {\n    const startOffset = this.stream.offset;\n    await this.stream.writeNextUint32(0);\n    await this.stream.writeNextString(box.type, 4);\n\n    await this.writeContents(box);\n\n    const endOffset = this.stream.offset;\n    const size = endOffset - startOffset;\n    await this.stream.seek(startOffset);\n    await this.stream.writeNextUint32(size);\n\n    await this.stream.seek(endOffset);\n  }\n\n  abstract writeContents(box: T): Promise<void>;\n}\n\nabstract class FullBoxWriter<T extends BaseFullBox> extends BoxWriter<T> {\n  async writeContents(box: T): Promise<void> {\n    await this.stream.writeNextUint8(box.fullBoxHeader!.version);\n\n    await this.stream.writeNextUint8(box.fullBoxHeader!.flags >> 16);\n    await this.stream.writeNextUint8(box.fullBoxHeader!.flags >> 8);\n    await this.stream.writeNextUint8(box.fullBoxHeader!.flags);\n  }\n}\n\nexport class FtypBoxWriter extends BoxWriter<FtypBox> {\n  async writeContents(box: FtypBox): Promise<void> {\n    await this.stream.writeNextString(box.majorBrand, 4);\n    await this.stream.writeNextUint32(box.minorVersion);\n\n    for (const compatibleBrand of box.compatibleBrands) {\n      await this.stream.writeNextString(compatibleBrand, 4);\n    }\n  }\n}\n\nexport class AvcCBoxWriter extends BoxWriter<AvcCBox> {\n  async writeContents(box: AvcCBox): Promise<void> {\n    await this.stream.writeNextUint8(box.configurationVersion);\n\n    await this.stream.writeNextUint8(box.profileIndication);\n    await this.stream.writeNextUint8(box.profileCompatibility);\n    await this.stream.writeNextUint8(box.levelIndication);\n    await this.stream.writeNextUint8(box.lengthSizeMinusOne | 0xfc);\n\n    await this.stream.writeNextUint8(box.sequenceParameterSets.length | 0xe0);\n    for (const sequenceParameterSet of box.sequenceParameterSets) {\n      await this.stream.writeNextUint16(sequenceParameterSet.byteLength);\n      await this.stream.writeNextBytes(sequenceParameterSet);\n    }\n\n    await this.stream.writeNextUint8(box.pictureParameterSets.length);\n    for (const pictureParameterSets of box.pictureParameterSets) {\n      await this.stream.writeNextUint16(pictureParameterSets.byteLength);\n      await this.stream.writeNextBytes(pictureParameterSets);\n    }\n  }\n}\n\nexport class Avc1BoxWriter extends BoxWriter<Avc1Box> {\n  // TODO: Generalise as a SampleEntryBoxWriter\n\n  async writeContents(box: Avc1Box): Promise<void> {\n    // From SampleEntry\n    await this.stream.skip(6);\n    await this.stream.writeNextUint16(box.dataReferenceIndex);\n\n    // From VisualSampleEntry\n    await this.stream.skip(2 * 2 + 4 * 3);\n\n    await this.stream.writeNextUint16(box.width);\n    await this.stream.writeNextUint16(box.height);\n\n    await this.stream.writeNextUint32(box.horizontalResolution);\n    await this.stream.writeNextUint32(box.verticalResolution);\n\n    await this.stream.skip(4);\n\n    await this.stream.writeNextUint16(box.frameCount);\n    await this.stream.writeNextString(box.compressorName, 32);\n    await this.stream.writeNextUint16(box.depth);\n\n    await this.stream.writeNextUint16(0xffff);\n\n    // From AVCSampleEntry\n    await writeBox(this.stream, box.avcC);\n  }\n}\n\nexport class StsdBoxWriter extends FullBoxWriter<StsdBox> {\n  async writeContents(box: StsdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await writeBox(this.stream, entry);\n    }\n  }\n}\n\nexport class StblBoxWriter extends BoxWriter<StblBox> {\n  async writeContents(box: StblBox): Promise<void> {\n    if (box.stco && box.co64) {\n      throw new Error(\"stbl box cannot contain both stco and co64\");\n    }\n\n    if (box.stco) {\n      await writeBox(this.stream, box.stco);\n    } else if (box.co64) {\n      await writeBox(this.stream, box.co64);\n    }\n\n    await writeBox(this.stream, box.stsc);\n    await writeBox(this.stream, box.stsd);\n    await writeBox(this.stream, box.stss);\n    await writeBox(this.stream, box.stsz);\n    await writeBox(this.stream, box.stts);\n  }\n}\n\nexport class UrlBoxWriter extends FullBoxWriter<UrlBox> {\n  async writeContents(box: UrlBox): Promise<void> {\n    await super.writeContents(box);\n\n    if (box.fullBoxHeader!.flags !== 1) {\n      await this.stream.writeNextString(box.location);\n    }\n  }\n}\n\nexport class UrnBoxWriter extends FullBoxWriter<UrnBox> {\n  async writeContents(box: UrnBox): Promise<void> {\n    await super.writeContents(box);\n\n    if (box.fullBoxHeader!.flags !== 1) {\n      await this.stream.writeNextString(box.name);\n      await this.stream.writeNextString(box.location);\n    }\n  }\n}\n\nexport class DinfBoxWriter extends BoxWriter<DinfBox> {\n  async writeContents(box: DinfBox): Promise<void> {\n    await writeBox(this.stream, box.dref);\n  }\n}\n\nexport class DrefBoxWriter extends FullBoxWriter<DrefBox> {\n  async writeContents(box: DrefBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await writeBox(this.stream, entry);\n    }\n  }\n}\n\nexport class VmhdBoxWriter extends FullBoxWriter<VmhdBox> {\n  async writeContents(box: VmhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint16(box.graphicsMode);\n    for (const color of box.opColor) {\n      await this.stream.writeNextUint16(color);\n    }\n  }\n}\n\nexport class HdlrBoxWriter extends FullBoxWriter<HdlrBox> {\n  async writeContents(box: HdlrBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.skip(4);\n    await this.stream.writeNextString(box.handlerType, 4);\n    await this.stream.skip(4 * 3);\n    await this.stream.writeNextString(box.name);\n  }\n}\n\nexport class StcoBoxWriter extends FullBoxWriter<StcoBox> {\n  async writeContents(box: StcoBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.chunkOffsets.length);\n    for (const chunkOffset of box.chunkOffsets) {\n      await this.stream.writeNextUint32(chunkOffset);\n    }\n  }\n}\n\nexport class StszBoxWriter extends FullBoxWriter<StszBox> {\n  async writeContents(box: StszBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(\n      box.sampleSizes.length > 1 ? 0 : box.sampleSizes[0]\n    );\n    await this.stream.writeNextUint32(box.sampleCount);\n    for (const sampleSize of box.sampleSizes) {\n      await this.stream.writeNextUint32(sampleSize);\n    }\n  }\n}\n\nexport class StscBoxWriter extends FullBoxWriter<StscBox> {\n  async writeContents(box: StscBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await this.stream.writeNextUint32(entry.firstChunk);\n      await this.stream.writeNextUint32(entry.samplesPerChunk);\n      await this.stream.writeNextUint32(entry.sampleDescriptionIndex);\n    }\n  }\n}\n\nexport class SttsBoxWriter extends FullBoxWriter<SttsBox> {\n  async writeContents(box: SttsBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await this.stream.writeNextUint32(entry.sampleCount);\n      await this.stream.writeNextUint32(entry.sampleDelta);\n    }\n  }\n}\n\nexport class StssBoxWriter extends FullBoxWriter<StssBox> {\n  async writeContents(box: StssBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.sampleNumbers.length);\n    for (const sampleNumber of box.sampleNumbers) {\n      await this.stream.writeNextUint32(sampleNumber);\n    }\n  }\n}\n\nexport class MdhdBoxWriter extends FullBoxWriter<MdhdBox> {\n  async writeContents(box: MdhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.creationTime);\n    await this.stream.writeNextUint32(box.modificationTime);\n    await this.stream.writeNextUint32(box.timescale);\n    await this.stream.writeNextUint32(box.duration);\n\n    await this.stream.writeNextUint16(0x55c4); // ISO-639-2/T code for \"undetermined\"\n    await this.stream.skip(2);\n  }\n}\n\nexport class TkhdBoxWriter extends FullBoxWriter<TkhdBox> {\n  async writeContents(box: TkhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.creationTime);\n    await this.stream.writeNextUint32(box.modificationTime);\n    await this.stream.writeNextUint32(box.trackId);\n\n    await this.stream.skip(4);\n\n    await this.stream.writeNextUint32(box.duration);\n\n    await this.stream.skip(4 * 2);\n\n    await this.stream.writeNextUint16(box.layer);\n    await this.stream.writeNextUint16(box.alternateGroup);\n    await this.stream.writeNextUint16(box.volume);\n\n    await this.stream.skip(2);\n\n    for (const matrix of box.matrix) {\n      await this.stream.writeNextUint32(matrix);\n    }\n\n    await this.stream.writeNextUint32(box.width);\n    await this.stream.writeNextUint32(box.height);\n  }\n}\n\nexport class MvhdBoxWriter extends FullBoxWriter<MvhdBox> {\n  async writeContents(box: MvhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.creationTime);\n    await this.stream.writeNextUint32(box.modificationTime);\n    await this.stream.writeNextUint32(box.timescale);\n    await this.stream.writeNextUint32(box.duration);\n\n    await this.stream.writeNextUint32(box.rate);\n    await this.stream.writeNextUint16(box.volume);\n\n    await this.stream.skip(2 + 4 * 2);\n\n    for (const matrix of box.matrix) {\n      await this.stream.writeNextUint32(matrix);\n    }\n\n    await this.stream.skip(4 * 6);\n\n    await this.stream.writeNextUint32(box.nextTrackId);\n  }\n}\n\nexport class MinfBoxWriter extends BoxWriter<MinfBox> {\n  async writeContents(box: MinfBox): Promise<void> {\n    await writeBox(this.stream, box.vmhd!);\n    await writeBox(this.stream, box.dinf!);\n    await writeBox(this.stream, box.stbl!);\n  }\n}\n\nexport class MdiaBoxWriter extends BoxWriter<MdiaBox> {\n  async writeContents(box: MdiaBox): Promise<void> {\n    await writeBox(this.stream, box.mdhd!);\n    await writeBox(this.stream, box.hdlr!);\n    await writeBox(this.stream, box.minf!);\n  }\n}\n\nexport class TrakBoxWriter extends BoxWriter<TrakBox> {\n  async writeContents(box: TrakBox): Promise<void> {\n    await writeBox(this.stream, box.tkhd!);\n    await writeBox(this.stream, box.mdia!);\n  }\n}\n\nexport class MoovBoxWriter extends BoxWriter<MoovBox> {\n  async writeContents(box: MoovBox): Promise<void> {\n    await writeBox(this.stream, box.mvhd!);\n    for (const trak of box.trak) {\n      await writeBox(this.stream, trak);\n    }\n  }\n}\n\nexport class MdatBoxStreamWriter {\n  private startOffset: number = 0;\n  private sizeOffset: number = 0;\n\n  private opened = false;\n  private closed = false;\n\n  constructor(private readonly stream: FileStreamWriter) {}\n\n  async open() {\n    if (this.opened) {\n      throw new Error(\"already opened\");\n    } else if (this.closed) {\n      throw new Error(\"already closed\");\n    }\n\n    this.startOffset = this.stream.offset;\n    await this.stream.writeNextUint32(1);\n    await this.stream.writeNextString(\"mdat\", 4);\n\n    this.sizeOffset = this.stream.offset;\n    await this.stream.writeNextUint64(0);\n\n    this.opened = true;\n  }\n\n  async write(bytes: Blob | BufferSource): Promise<void> {\n    if (!this.opened) {\n      throw new Error(\"not opened\");\n    } else if (this.closed) {\n      throw new Error(\"already closed\");\n    }\n\n    await this.stream.writeNextBytes(bytes);\n  }\n\n  async close() {\n    if (!this.opened) {\n      throw new Error(\"not opened\");\n    } else if (this.closed) {\n      throw new Error(\"already closed\");\n    }\n\n    const endOffset = this.stream.offset;\n\n    await this.stream.seek(this.sizeOffset);\n    await this.stream.writeNextUint64(endOffset - this.startOffset);\n    await this.stream.seek(endOffset);\n\n    this.closed = true;\n  }\n\n  get dataStartOffset(): number {\n    if (!this.opened) {\n      throw new Error(\"not opened\");\n    }\n\n    return this.startOffset + 16;\n  }\n}\n","import { FileStreamReader } from \"./io/reader\";\nimport { FileStreamWriter } from \"./io/writer\";\nimport {\n  Avc1Box,\n  AvcCBox,\n  Box,\n  DinfBox,\n  DrefBox,\n  FtypBox,\n  HdlrBox,\n  MdatBox,\n  MdhdBox,\n  MdiaBox,\n  MinfBox,\n  MoovBox,\n  MvhdBox,\n  StblBox,\n  StcoBox,\n  StscBox,\n  StsdBox,\n  StssBox,\n  StszBox,\n  SttsBox,\n  TkhdBox,\n  TrakBox,\n  UrlBox,\n  VmhdBox,\n} from \"./types\";\nimport { getMp4Time } from \"./utils\";\nimport { parseBox } from \"./parsers\";\nimport {\n  writeBox,\n  MdatBoxStreamWriter,\n} from \"./writers\";\n\nexport class MP4Parser {\n  private readonly stream: FileStreamReader;\n  mdat?: MdatBox;\n  moov?: MoovBox;\n\n  constructor(file: File) {\n    this.stream = new FileStreamReader(file);\n  }\n\n  async parse(): Promise<void> {\n    const ftyp = await this.parseBox();\n    if (ftyp.type !== \"ftyp\") {\n      throw new Error(\"Expected ftyp box at start of file. Not an MP4?\");\n    }\n\n    let mdat: MdatBox | undefined;\n    let moov: MoovBox | undefined;\n\n    while (!this.stream.eof) {\n      const box = await this.parseBox();\n\n      switch (box.type) {\n        case \"mdat\":\n          mdat = box;\n          break;\n        case \"moov\":\n          moov = box;\n          break;\n        default:\n          break;\n      }\n    }\n\n    if (!mdat || !moov) {\n      throw new Error(\"Missing mdat or moov box\");\n    }\n\n    this.mdat = mdat;\n    this.moov = moov;\n  }\n\n  async getSample(sampleNumber: number): Promise<{\n    data: Uint8Array;\n    sync: boolean;\n  }> {\n    const stbl = this.moov!.trak[0].mdia.minf.stbl;\n    const stsz = stbl.stsz;\n    const stco = stbl.stco ? stbl.stco : stbl.co64;\n\n    const sampleSize = stsz.sampleSizes[sampleNumber];\n\n    let chunkOffset = stco!.chunkOffsets[0];\n    let sampleOffset = chunkOffset;\n    for (let i = 0; i < sampleNumber; i++) {\n      sampleOffset += stbl.stsz.sampleSizes[i];\n    }\n\n    this.stream.seek(sampleOffset);\n    return {\n      data: await this.stream.getNextBytes(sampleSize),\n      sync: this.isSampleSync(sampleNumber),\n    };\n  }\n\n  isSampleSync(sampleNumber: number): boolean {\n    const stbl = this.moov!.trak[0].mdia.minf.stbl;\n    return stbl.stss.sampleNumbers.includes(sampleNumber + 1);\n  }\n\n  private async parseBox(): Promise<Box> {\n    return await parseBox(this.stream);\n  }\n}\n\nexport class MP4Writer {\n  private readonly stream: FileStreamWriter;\n  private readonly mdat: MdatBoxStreamWriter;\n  private avcC?: AvcCBox;\n\n  private sampleCount = 0;\n  private syncSamples: number[] = [];\n  private sampleSizes: number[] = [];\n\n  private displaySize?: { width: number; height: number };\n  private frameRate: number = 60;\n\n  constructor(file: FileSystemFileHandle) {\n    this.stream = new FileStreamWriter(file);\n    this.mdat = new MdatBoxStreamWriter(this.stream);\n  }\n\n  async open(): Promise<void> {\n    const ftyp: FtypBox = {\n      type: \"ftyp\",\n      majorBrand: \"isom\",\n      minorVersion: 0,\n      compatibleBrands: [\"mp41\", \"avc1\", \"isom\"],\n    };\n\n    await writeBox(this.stream, ftyp);\n    await this.mdat.open();\n  }\n\n  async writeSample(data: Blob | BufferSource, sync: boolean) {\n    await this.mdat.write(data);\n\n    if (sync) {\n      this.syncSamples.push(this.sampleCount + 1);\n    }\n\n    this.sampleSizes.push(data instanceof Blob ? data.size : data.byteLength);\n    this.sampleCount++;\n  }\n\n  setAvcC(avcCStruct: ArrayBuffer | ArrayBufferView) {\n    // TODO: Make a nice stream view for this.\n    let view: DataView;\n    if (avcCStruct instanceof ArrayBuffer) {\n      view = new DataView(avcCStruct);\n    } else {\n      view = new DataView(\n        avcCStruct.buffer,\n        avcCStruct.byteOffset,\n        avcCStruct.byteLength\n      );\n    }\n\n    let avcC: AvcCBox = {\n      type: \"avcC\",\n      configurationVersion: view.getUint8(0),\n      profileIndication: view.getUint8(1),\n      profileCompatibility: view.getUint8(2),\n      levelIndication: view.getUint8(3),\n      lengthSizeMinusOne: view.getUint8(4) & 0x3,\n      sequenceParameterSets: [],\n      pictureParameterSets: [],\n    } as AvcCBox;\n\n    let offset: number = 5;\n\n    const spsCount = view.getUint8(offset) & 0x1f;\n    offset += 1;\n\n    const sps = [];\n    for (let i = 0; i < spsCount; i++) {\n      const spsLength = view.getUint16(offset);\n      offset += 2;\n\n      const spsData = new Uint8Array(\n        view.buffer,\n        view.byteOffset + offset,\n        spsLength\n      );\n      sps.push(spsData);\n      offset += spsLength;\n    }\n\n    const ppsCount = view.getUint8(offset);\n    offset += 1;\n\n    const pps = [];\n    for (let i = 0; i < ppsCount; i++) {\n      const ppsLength = view.getUint16(offset);\n      offset += 2;\n\n      const ppsData = new Uint8Array(\n        view.buffer,\n        view.byteOffset + offset,\n        ppsLength\n      );\n      pps.push(ppsData);\n      offset += ppsLength;\n    }\n\n    avcC.sequenceParameterSets = sps;\n    avcC.pictureParameterSets = pps;\n\n    this.avcC = avcC;\n  }\n\n  setDisplaySize(options: { width: number; height: number }) {\n    this.displaySize = {\n      width: options.width,\n      height: options.height,\n    };\n  }\n\n  setFramerate(framerate: number) {\n    this.frameRate = framerate;\n  }\n\n  async close() {\n    await this.mdat.close();\n\n    const moov: MoovBox = {\n      type: \"moov\",\n      mvhd: this.getMvhdBox(),\n      trak: [this.getTrakBox()],\n    };\n\n    await writeBox(this.stream, moov);\n    await this.stream.close();\n  }\n\n  private getTrakBox(): TrakBox {\n    return {\n      type: \"trak\",\n      tkhd: this.getTkhdBox(),\n      mdia: this.getMdiaBox(),\n    };\n  }\n\n  private getTkhdBox(): TkhdBox {\n    const now = new Date();\n    const nowMp4Time = getMp4Time(now);\n\n    return {\n      type: \"tkhd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0x3, // Enabled and in movie\n      },\n      alternateGroup: 0,\n      creationTime: nowMp4Time,\n      duration: Math.floor((this.sampleCount * 1000) / this.frameRate),\n      width: this.displaySize!.width,\n      height: this.displaySize!.height,\n      layer: 0,\n      matrix: [0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000],\n      modificationTime: nowMp4Time,\n      trackId: 1,\n      volume: 0,\n    };\n  }\n\n  private getMvhdBox(): MvhdBox {\n    const now = new Date();\n    const nowMp4Time = getMp4Time(now);\n\n    return {\n      type: \"mvhd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      duration: Math.floor((this.sampleCount * 1000) / this.frameRate),\n      creationTime: nowMp4Time,\n      modificationTime: nowMp4Time,\n      timescale: 1000,\n      rate: 0x00010000,\n      volume: 0x0100,\n      matrix: [0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000],\n      nextTrackId: 2,\n    };\n  }\n\n  private getMdiaBox(): MdiaBox {\n    return {\n      type: \"mdia\",\n      hdlr: {\n        type: \"hdlr\",\n        fullBoxHeader: {\n          version: 0,\n          flags: 0,\n        },\n        handlerType: \"vide\",\n        name: \"VideoHandler\",\n      } as HdlrBox,\n      minf: this.getMinfBox(),\n      mdhd: this.getMdhdBox(),\n    } as MdiaBox;\n  }\n\n  private getMdhdBox(): MdhdBox {\n    const now = new Date();\n    const nowMp4Time = getMp4Time(now);\n\n    return {\n      type: \"mdhd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      creationTime: nowMp4Time,\n      duration: this.sampleCount,\n      language: \"\",\n      modificationTime: nowMp4Time,\n      timescale: this.frameRate,\n    };\n  }\n\n  private getMinfBox(): MinfBox {\n    const stbl = this.getStblBox();\n    const dinf = this.getDinfBox();\n\n    return {\n      type: \"minf\",\n      dinf,\n      stbl,\n      vmhd: {\n        type: \"vmhd\",\n        fullBoxHeader: {\n          version: 0,\n          flags: 1,\n        },\n        graphicsMode: 0,\n        opColor: [0, 0, 0],\n      } as VmhdBox,\n    };\n  }\n\n  private getDinfBox(): DinfBox {\n    // Always reports that the data is in the same file.\n    return {\n      type: \"dinf\",\n      dref: {\n        type: \"dref\",\n        fullBoxHeader: {\n          version: 0,\n          flags: 0,\n        },\n        entries: [\n          {\n            type: \"url \",\n            fullBoxHeader: {\n              version: 0,\n              flags: 1,\n            },\n            location: \"\",\n          } as UrlBox,\n        ],\n      } as DrefBox,\n    } as DinfBox;\n  }\n\n  private getStblBox(): StblBox {\n    const stco: StcoBox = {\n      type: \"stco\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      chunkOffsets: [this.mdat.dataStartOffset],\n    };\n\n    const stsc: StscBox = {\n      type: \"stsc\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      entries: [\n        {\n          firstChunk: 1,\n          samplesPerChunk: this.sampleCount,\n          sampleDescriptionIndex: 1,\n        },\n      ],\n    };\n\n    const stsd: StsdBox = {\n      type: \"stsd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      entries: [\n        {\n          type: \"avc1\",\n          dataReferenceIndex: 1,\n          width: this.displaySize!.width,\n          height: this.displaySize!.height,\n          horizontalResolution: 0x00480000,\n          verticalResolution: 0x00480000,\n          frameCount: 1,\n          compressorName: \"mp4.ts\",\n          depth: 24,\n          avcC: this.avcC!,\n        } as Avc1Box,\n      ],\n    };\n\n    const stss: StssBox = {\n      type: \"stss\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      sampleNumbers: this.syncSamples,\n    };\n\n    const stsz: StszBox = {\n      type: \"stsz\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      sampleCount: this.sampleCount,\n      sampleSizes: this.sampleSizes,\n    };\n\n    const stts: SttsBox = {\n      type: \"stts\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      entries: [\n        {\n          sampleCount: this.sampleCount,\n          sampleDelta: 1,\n        },\n      ],\n    };\n\n    const stbl: StblBox = {\n      type: \"stbl\",\n      stco,\n      stsc,\n      stsd,\n      stss,\n      stsz,\n      stts,\n    };\n\n    return stbl;\n  }\n}\n","/* eslint-disable no-restricted-globals */\nimport { StreamDataView } from \"stream-data-view\";\n\nimport VideoWorkerShared from \"./shared\";\nimport {\n  MP4Parser,\n  MP4Writer,\n} from \"./mp4\";\nimport {\n  Avc1Box,\n  AvcCBox,\n} from \"./mp4/types\";\n\nconst PROGRESS_UPDATE_INTERVAL = 100;\n\nfunction avcCBoxToDescription(avcCBox: AvcCBox): ArrayBuffer {\n  const stream = new StreamDataView(undefined, true);\n\n  stream.setNextUint8(avcCBox.configurationVersion);\n  stream.setNextUint8(avcCBox.profileIndication);\n  stream.setNextUint8(avcCBox.profileCompatibility);\n  stream.setNextUint8(avcCBox.levelIndication);\n  stream.setNextUint8(avcCBox.lengthSizeMinusOne + (63 << 2));\n\n  stream.setNextUint8(avcCBox.sequenceParameterSets.length + (7 << 5));\n  for (let i = 0; i < avcCBox.sequenceParameterSets.length; i++) {\n    stream.setNextUint16(avcCBox.sequenceParameterSets[i].length);\n    for (let j = 0; j < avcCBox.sequenceParameterSets[i].length; j++) {\n      stream.setNextUint8(avcCBox.sequenceParameterSets[i][j]);\n    }\n  }\n\n  stream.setNextUint8(avcCBox.pictureParameterSets.length);\n  for (let i = 0; i < avcCBox.pictureParameterSets.length; i++) {\n    stream.setNextUint16(avcCBox.pictureParameterSets[i].length);\n    for (let j = 0; j < avcCBox.pictureParameterSets[i].length; j++) {\n      stream.setNextUint8(avcCBox.pictureParameterSets[i][j]);\n    }\n  }\n\n  return stream.getBuffer();\n}\n\ntype ModifyFrameCallback = (frame: ImageBitmap, index: number) => ImageBitmap;\n\ntype ProgressInitCallback = (options: {\n  expectedFrames: number;\n}) => void;\n\ntype ProgressCallback = (options: {\n  framesDecoded?: number;\n  framesDecodedMissing?: number;\n  framesEncoded?: number;\n  preview?: ImageBitmap;\n  queuedForDecode?: number;\n  queuedForEncode?: number;\n  inEncoderQueue?: number;\n  inDecoderQueue?: number;\n}) => void;\n\nexport interface ProcessorOptions {\n  modifyFrame: ModifyFrameCallback;\n  progressInit: ProgressInitCallback;\n  progressUpdate: ProgressCallback;\n}\n\ninterface DecodedFrame {\n  index: number;\n  image?: ImageBitmap\n  sync: boolean;\n}\n\ninterface EncodedFrame {\n  data: ArrayBuffer;\n  timestamp: number;\n  sync: boolean;\n}\n\nexport class Processor {\n  decoder?: VideoDecoder;\n  encoder?: VideoEncoder;\n\n  inMp4?: MP4Parser;\n  outMp4?: MP4Writer;\n\n  expectedFrames: number = 0;\n  framesDecoded: number = 0;\n  framesDecodedMissing: number = 0;\n  framesEncoded: number = 0;\n  queuedForDecode: number = 0;\n  queuedForEncode: number = 0;\n\n  modifyFrame: ModifyFrameCallback;\n  progressInit: ProgressInitCallback;\n  progressUpdate: ProgressCallback;\n\n  processResolve?: () => void;\n  processReject?: (reason?: any) => void;\n\n  progressUpdateIntervalHandle?: number;\n\n  decodedFrames: Record<number, DecodedFrame> = {};\n  encodedFrames: EncodedFrame[] = [];\n\n  constructor(options: ProcessorOptions) {\n    this.modifyFrame = options.modifyFrame;\n    this.progressInit = options.progressInit;\n    this.progressUpdate = options.progressUpdate;\n\n    this.sendProgressUpdate = this.sendProgressUpdate.bind(this);\n  }\n\n  async open(file: File, outHandle: FileSystemFileHandle) {\n    this.reset();\n\n    this.inMp4 = new MP4Parser(file);\n    await this.inMp4.parse();\n\n    this.outMp4 = new MP4Writer(outHandle);\n    await this.outMp4.open();\n\n    return {\n      width: this.inMp4.moov!.trak[0].tkhd.width,\n      height: this.inMp4.moov!.trak[0].tkhd.height,\n    };\n  }\n\n  process(options: { width: number; height: number }): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.processResolve = resolve;\n      this.processReject = reject;\n\n      try {\n        const avc1box = this.inMp4!.moov!.trak[0].mdia.minf.stbl.stsd\n          .entries[0] as Avc1Box;\n        const codec =\n          \"avc1.\" +\n          avc1box.avcC.profileIndication.toString(16).padStart(2, \"0\") +\n          avc1box.avcC.profileCompatibility.toString(16).padStart(2, \"0\") +\n          avc1box.avcC.levelIndication.toString(16).padStart(2, \"0\");\n\n        this.decoder!.configure({\n          codec: codec,\n          codedWidth: this.inMp4!.moov!.trak[0].tkhd.width,\n          codedHeight: this.inMp4!.moov!.trak[0].tkhd.height,\n          description: avcCBoxToDescription(\n            (this.inMp4!.moov!.trak[0].mdia.minf.stbl.stsd.entries[0] as Avc1Box)\n              .avcC\n          ),\n          optimizeForLatency: false,\n        });\n      } catch (e: any) {\n        throw new VideoWorkerShared.DecoderConfigureError(e);\n      }\n\n      try {\n        let bitrate =\n          (this.inMp4!.mdat!.header!.size * 8 * this.inMp4!.moov!.mvhd.timescale) /\n          this.inMp4!.moov!.mvhd.duration;\n        bitrate = Math.ceil(bitrate / 5_000_000) * 5_000_000;\n\n        this.encoder!.configure({\n          bitrate: bitrate,\n          codec: \"avc1.42003d\",\n          framerate: 60,\n          height: options.height,\n          latencyMode: \"quality\",\n          scalabilityMode: \"L1T2\",\n          width: options.width,\n        });\n      } catch (e: any) {\n        throw new VideoWorkerShared.EncoderConfigureError(e);\n      }\n\n      this.outMp4?.setDisplaySize({\n        width: options.width,\n        height: options.height,\n      });\n\n      this.outMp4?.setFramerate(60);\n\n      this.expectedFrames = this.inMp4!.moov!.trak[0].mdia.minf.stbl.stsz.sampleCount;\n      this.decodedFrames = {};\n\n      this.progressInit({ expectedFrames: this.expectedFrames });\n\n      this.progressUpdateIntervalHandle = self.setInterval(this.sendProgressUpdate, PROGRESS_UPDATE_INTERVAL);\n\n      this.processSamples();\n    });\n  }\n\n  private reset() {\n    if (this.encoder) {\n      this.encoder.close();\n    }\n\n    this.encoder = new VideoEncoder({\n      output: this.handleEncodedFrame.bind(this),\n      error: this.handleEncoderError.bind(this),\n    });\n\n    if (this.decoder) {\n      this.decoder.close();\n    }\n\n    this.decoder = new VideoDecoder({\n      output: this.handleDecodedFrame.bind(this),\n      error: this.handleDecoderError.bind(this),\n    });\n\n    this.expectedFrames = 0;\n    this.framesDecoded = 0;\n    this.framesDecodedMissing = 0;\n    this.framesEncoded = 0;\n    this.queuedForDecode = 0;\n    this.queuedForEncode = 0;\n\n    this.processResolve = undefined;\n    this.processReject = undefined;\n\n    if (this.progressUpdateIntervalHandle) {\n      clearInterval(this.progressUpdateIntervalHandle);\n    }\n  }\n\n  private async processSamples() {\n    let lastSampleIndex = 0;\n    while (lastSampleIndex < this.expectedFrames) {\n      // Load samples up to next keyframe.\n      const sampleChunks = [];\n      for (let sampleIndex = lastSampleIndex; sampleIndex < this.expectedFrames; sampleIndex++) {\n        const sample = await this.inMp4!.getSample(sampleIndex);\n        sampleChunks.push({\n          index: sampleIndex,\n          data: sample.data.buffer,\n          sync: sample.sync,\n        });\n\n        if (sampleIndex + 1 < this.expectedFrames && this.inMp4!.isSampleSync(sampleIndex + 1)) {\n          break;\n        }\n      }\n\n      // Prepare expected frames object, which the callback will toot into.\n      this.decodedFrames = {};\n      for (const chunk of sampleChunks) {\n        this.decodedFrames[chunk.index] = {\n          index: chunk.index,\n          image: undefined,\n          sync: chunk.sync,\n        };\n      }\n\n      // Enqueue samples for decoding.\n      for (const chunk of sampleChunks) {\n        const encodedChunk = new EncodedVideoChunk({\n          type: chunk.sync ? \"key\" : \"delta\",\n          timestamp: chunk.index,\n          duration: 16670,\n          data: chunk.data,\n        });\n\n        this.decoder!.decode(encodedChunk);\n        this.queuedForDecode++;\n      }\n\n      // Wait for all samples to be decoded.\n      await this.decoder!.flush();\n\n      // DJI recordings straight from the goggles have all frames in sequence.\n      // Processed files may need reordering of the frames described in the ctts box.\n      const orderedFrames = this.reorderFrames(lastSampleIndex);\n\n      // Modify and enqueue frames for encoding.\n      this.encodedFrames = [];\n      for (const [index, entry] of orderedFrames.entries()) {\n        if (!entry.image) {\n          console.error(`Frame ${entry.index} was never decoded!`);\n          this.framesDecodedMissing++;\n          continue;\n        }\n\n        const modifiedFrame = this.modifyFrame(entry.image!, entry.index);\n        const frame = new VideoFrame(modifiedFrame, {\n          duration: 16670,\n          timestamp: entry.index,\n        });\n\n        // Send first frame as preview. This needs to happen after constructing the frame otherwise\n        // it complains that \"the image source is detached\" which is completely ungooglable.\n        if (index === 0) {\n          this.progressUpdate({ preview: modifiedFrame });\n        }\n\n        this.encoder!.encode(frame, { keyFrame: entry.sync });\n        this.queuedForEncode++;\n        frame.close();\n      }\n\n      // Wait for all frames to be encoded.\n      await this.encoder!.flush();\n\n      // Write encoded frames to output.\n      for (const frame of this.encodedFrames) {\n        this.outMp4!.writeSample(frame.data, frame.sync);\n      }\n\n      lastSampleIndex += sampleChunks.length;\n    }\n\n    await this.outMp4!.close();\n    this.sendProgressUpdate();\n    this.processResolve!();\n  }\n\n  private reorderFrames(lastSampleIndex: number) {\n    const orderedFrames = [];\n    const ctts = this.inMp4!.moov!.trak[0].mdia.minf.stbl.ctts;\n\n    if (!ctts) {\n      // No ctts box found: no reordering needed\n      for (let i = 0; i < Object.keys(this.decodedFrames).length; i++) {\n        orderedFrames.push(this.decodedFrames[lastSampleIndex + i]);\n      }\n    } else {\n      // Reorder frames according to ctts table\n      const sampleDelta = this.inMp4!.moov!.trak[0].mdia.minf.stbl.stts.entries[0].sampleDelta;\n      const initialOffset = ctts.sampleOffsets[0] / sampleDelta;\n\n      for (let i = 0; i < Object.keys(this.decodedFrames).length; i++) {\n        const frameNumber = lastSampleIndex + i;\n\n        let j = 0;\n        let frame = 0;\n        while (frameNumber >= frame) {\n          j++;\n          frame = ctts.sampleCounts.slice(0, j).reduce((acc, e) => acc + e, 0);\n        }\n\n        const newPosition = i + ctts.sampleOffsets[j - 1] / sampleDelta - initialOffset;\n        orderedFrames[newPosition] = Object.assign({}, this.decodedFrames[lastSampleIndex + i], { index: lastSampleIndex + newPosition });\n      }\n    }\n\n    return orderedFrames;\n  }\n\n  private async handleDecodedFrame(frame: VideoFrame) {\n    this.framesDecoded++;\n    this.decodedFrames[frame.timestamp!].image = await createImageBitmap(frame);\n    frame.close();\n  }\n\n  private handleEncodedFrame(\n    chunk: EncodedVideoChunk,\n    metadata: EncodedVideoChunkMetadata\n  ) {\n    this.framesEncoded++;\n\n    const buffer = new ArrayBuffer(chunk.byteLength);\n    chunk.copyTo(buffer);\n    this.encodedFrames.push({\n      data: buffer,\n      sync: chunk.type === \"key\",\n      timestamp: chunk.timestamp,\n    });\n\n    // avcC is only available on the first frame.\n    if (chunk.timestamp === 0) {\n      this.outMp4!.setAvcC(metadata.decoderConfig?.description!);\n    }\n  }\n\n  private handleDecoderError(e: Error) {\n    this.processReject!(new VideoWorkerShared.DecoderError(e.message));\n    throw e;\n  }\n\n  private handleEncoderError(e: Error) {\n    this.processReject!(new VideoWorkerShared.EncoderError(e.message));\n    throw e;\n  }\n\n  private sendProgressUpdate() {\n    this.progressUpdate({\n      framesDecoded: this.framesDecoded,\n      framesDecodedMissing: this.framesDecodedMissing,\n      framesEncoded: this.framesEncoded,\n      queuedForDecode: this.queuedForDecode,\n      queuedForEncode: this.queuedForEncode,\n      inDecoderQueue: this.decoder?.decodeQueueSize,\n      inEncoderQueue: this.encoder?.encodeQueueSize,\n    });\n  }\n}\n","import { OsdReader } from \"./osd\";\nexport const SD_TILE_WIDTH = 12 * 3;\nexport const SD_TILE_HEIGHT = 18 * 3;\n\nexport const HD_TILE_WIDTH = 12 * 2;\nexport const HD_TILE_HEIGHT = 18 * 2;\n\nexport const TILES_PER_PAGE = 256;\n\nexport interface FontPack {\n  sd: Font;\n  hd: Font;\n}\n\nexport interface FontPackFiles {\n  sd: File;\n  hd: File;\n}\n\nexport class Font {\n  readonly name: string;\n  readonly tiles: ImageBitmap[];\n\n  constructor(name: string, tiles: ImageBitmap[]) {\n    this.name = name;\n    this.tiles = tiles;\n  }\n\n  getTile(index: number): ImageBitmap {\n    return this.tiles[index];\n  }\n\n  static async fromFile(file: File, isHd : boolean, reader: OsdReader): Promise<Font> {\n    const [filename, data] = await (async (file : File) => {\n      if (file && file.size > 0) {\n        return [file.name, await file.arrayBuffer()];\n      } else {\n        const font_filename = `font_${reader.header.config.fontVariant.toLowerCase()}${isHd ? \"_hd\" : \"\"}.png`;\n        return [\"font_filename\", await fetch(`https://raw.githubusercontent.com/fpv-wtf/msp-osd/main/fonts/${font_filename}`).then((response) => response.arrayBuffer())];\n      }\n    })(file);\n\n    const tileWidth = isHd ? HD_TILE_WIDTH : SD_TILE_WIDTH;\n    const tileHeight = isHd ? HD_TILE_HEIGHT : SD_TILE_HEIGHT;\n\n    // Create an image bitmap from the ArrayBuffer\n    const imageBitmap = await createImageBitmap(new Blob([data]));\n\n    const canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n    const context = canvas.getContext(\"2d\");\n\n    if (!context) {\n      throw new Error(\"2D context not supported or canvas creation failed\");\n    }\n\n    context.drawImage(imageBitmap, 0, 0);\n\n    const tiles = [];\n    const tilesPerColumn = TILES_PER_PAGE; // Number of tiles per column\n    const columns = imageBitmap.width / tileWidth; // Number of columns\n\n    for (let columnIndex = 0; columnIndex < columns; columnIndex++) {\n      for (let rowIndex = 0; rowIndex < tilesPerColumn; rowIndex++) {\n        const x = columnIndex * tileWidth; // x-coordinate based on column\n        const y = rowIndex * tileHeight; // y-coordinate based on row\n\n        const imageData = context.getImageData(x, y, tileWidth, tileHeight);\n        const tileBitmap = await createImageBitmap(imageData);\n        tiles.push(tileBitmap);\n      }\n    }\n\n    return new Font(filename, tiles);\n  }\n\n  static async fromFiles(files: FontPackFiles, reader: OsdReader): Promise<FontPack> {\n    return {\n      sd: await Font.fromFile(files.sd, false, reader),\n      hd: await Font.fromFile(files.hd, true, reader),\n    };\n  }\n}\n","import { StreamDataView } from \"stream-data-view\";\n\ninterface OsdHeader {\n  magic: string;\n  version: number;\n  config: OsdConfig;\n}\n\ninterface OsdConfig {\n  charWidth: number;\n  charHeight: number;\n  fontWidth: number;\n  fontHeight: number;\n  xOffset: number;\n  yOffset: number;\n  fontVariant:  string;\n}\n\ninterface OsdHeaderV1 {\n  magic: string;\n  version: number;\n  config: OsdConfigV1;\n}\n\ninterface OsdConfigV1 {\n  charWidth: number;\n  charHeight: number;\n  fontWidth: number;\n  fontHeight: number;\n  xOffset: number;\n  yOffset: number;\n  fontVariant: number;\n}\n\ninterface OsdFrame {\n  frameNumber: number;\n  frameSize: number;\n  frameData: Uint16Array;\n}\n\nexport class OsdReader {\n  readonly header: OsdHeader;\n  readonly frames: OsdFrame[] = [];\n\n  constructor(data: ArrayBuffer) {\n    const stream = new StreamDataView(data);\n    this.header = {\n      magic: stream.getNextString(7),\n      version: stream.getNextUint16(),\n      config: {\n        charWidth: stream.getNextUint8(),\n        charHeight: stream.getNextUint8(),\n        fontWidth: stream.getNextUint8(),\n        fontHeight: stream.getNextUint8(),\n        xOffset: stream.getNextUint16(),\n        yOffset: stream.getNextUint16(),\n        fontVariant: stream.getNextString(5).substring(0, 4), // read 5 bytes, keep 4. string is from c; null terminated. reading all 5 leaves pointer in right place to start reading frames below\n      },\n    };\n\n    // v1 of this format used a slightly different structure - fontVariant was a number, not a string\n    // in msp-osd itself an enum was used to store the FC variant, which became the number we have here\n    // since msp-osd 0.12 we use the FC identifier internally (so we don't need to rely on the magic enum)\n    // this maps the legacy enum to the correct string identifier, as well as leaving the file pointer\n    // in the correct place for a legacy file\n    if (this.header.version === 1) {\n      stream.resetOffset();\n      const tempheader : OsdHeaderV1  = {\n        magic: stream.getNextString(7),\n        version: stream.getNextUint16(),\n        config: {\n          charWidth: stream.getNextUint8(),\n          charHeight: stream.getNextUint8(),\n          fontWidth: stream.getNextUint8(),\n          fontHeight: stream.getNextUint8(),\n          xOffset: stream.getNextUint16(),\n          yOffset: stream.getNextUint16(),\n          fontVariant: stream.getNextUint8(),\n        },\n      };\n\n      switch (tempheader.config.fontVariant) {\n        case 1: // FONT_VARIANT_BETAFLIGHT\n          this.header.config.fontVariant = \"BTFL\";\n          break;\n        case 2: // FONT_VARIANT_INAV\n          this.header.config.fontVariant = \"INAV\";\n          break;\n        case 3: // FONT_VARIANT_ARDUPILOT\n          this.header.config.fontVariant = \"ARDU\";\n          break;\n        case 4: // FONT_VARIANT_KISS_ULTRA\n          this.header.config.fontVariant = \"ULTR\";\n          break;\n        case 5: // FONT_VARIANT_QUICKSILVER\n          this.header.config.fontVariant = \"QUIC\";\n          break;\n        default:\n          this.header.config.fontVariant = \"\"; // Empty string for unknown variant\n      }\n    }\n\n    if (this.header.config.charWidth === 31) {\n      this.header.config.charWidth = 30;\n    }\n\n    while (stream.getOffset() < data.byteLength) {\n      try {\n        const frameNumber = stream.getNextUint32();\n        const frameSize = stream.getNextUint32();\n        const frameData = new Uint16Array(data, stream.getOffset(), frameSize);\n        stream.setOffset(stream.getOffset() + frameSize * 2);\n\n        this.frames.push({\n          frameNumber,\n          frameSize,\n          frameData,\n        });\n      } catch (e) {\n        if (e instanceof RangeError) {\n          console.warn(\"No more data in OSD file, probably truncated due to power loss\");\n          break;\n        }\n      }\n    }\n  }\n\n  static async fromFile(file: File): Promise<OsdReader> {\n    const data = await file.arrayBuffer();\n    return new OsdReader(data);\n  }\n}\n","interface SrtFrame {\n  start: number;\n  end: number;\n  signal: string;\n  ch: string;\n  flightTime: string;\n  uavBat: string;\n  glsBat: string;\n  uavBatCells: string;\n  glsBatCells: string;\n  delay: string;\n  bitrate:string;\n  rcSignal:string;\n}\n\nexport class SrtReader {\n  readonly frames: SrtFrame[] = [];\n\n  constructor(data: String) {\n    const blocks = data.split(\"\\n\\n\").slice(0, -1);\n\n    for (const block of blocks) {\n      const [ , timestamps, text ] = block.split(\"\\n\");\n      const [ startHours, startMinutes, startSeconds, startMilliseconds ] = timestamps\n        .substring(0, 12)\n        .split(/\\D/)\n        .map((it) => parseInt(it));\n      const [ endHours, endMinutes, endSeconds, endMilliseconds ] = timestamps\n        .substring(17)\n        .split(/\\D/)\n        .map((it) => parseInt(it));\n\n      const start = startHours * 1000 * 60 * 60 + startMinutes * 1000 * 60 + startSeconds * 1000 + startMilliseconds;\n      const end = endHours * 1000 * 60 * 60 + endMinutes * 1000 * 60 + endSeconds * 1000 + endMilliseconds;\n\n      const [ signalRaw, chRaw, flightTimeRaw, uavBatRaw, glsBatRaw, uavBatCellsRaw, glsBatCellsRaw, delayRaw, bitrateRaw, rcSignalRaw ] = text.split(\" \");\n      const signal = signalRaw.split(\":\")[1];\n      const ch = chRaw.split(\":\")[1];\n      const flightTime = parseInt(flightTimeRaw.split(\":\")[1]);\n      const uavBat = uavBatRaw.split(\":\")[1];\n      const glsBat = glsBatRaw.split(\":\")[1];\n      const uavBatCells = uavBatCellsRaw.split(\":\")[1];\n      const glsBatCells = glsBatCellsRaw.split(\":\")[1];\n      const delay = delayRaw.split(\":\")[1];\n      const bitrate = bitrateRaw.split(\":\")[1];\n      const rcSignal = rcSignalRaw.split(\":\")[1];\n\n      const formatFlightTime = (totalSeconds: number) => {\n        const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, \"0\");\n        const seconds = String(totalSeconds % 60).padStart(2, \"0\");\n        return `${minutes}' ${seconds}\"`;\n      };\n\n      this.frames.push({\n        start,\n        end,\n        signal,\n        ch: \"CH\" + ch,\n        flightTime: formatFlightTime(flightTime),\n        uavBat,\n        glsBat,\n        uavBatCells,\n        glsBatCells,\n        delay,\n        bitrate,\n        rcSignal,\n      });\n    }\n  }\n\n  static async fromFile(file: File): Promise<SrtReader> {\n    const data = await file.text();\n    return new SrtReader(data);\n  }\n}\n","/// <reference lib=\"webworker\" />\n\nimport VideoWorkerShared from \"./shared\";\nimport { Processor } from \"./processor\";\nimport {\n  Font,\n  FontPack,\n  FontPackFiles,\n} from \"./fonts\";\nimport { OsdReader } from \"./osd\";\nimport { SrtReader } from \"./srt\";\n\nconst MAX_DISPLAY_X = 60;\nconst MAX_DISPLAY_Y = 22;\n\nexport class VideoWorker {\n  readonly processor: Processor;\n\n  chromaKey: boolean = false;\n  chromaKeyColor: string = \"#ff00ff\";\n\n  fontPack?: FontPack;\n  osdReader?: OsdReader;\n  srtReader?: SrtReader;\n\n  lastOsdIndex: number = 0;\n\n  wide: boolean = false;\n  hd: boolean = false;\n  outWidth?: number;\n  outHeight?: number;\n\n  osdCanvas?: OffscreenCanvas;\n  osdCtx?: OffscreenCanvasRenderingContext2D;\n  frameCanvas?: OffscreenCanvas;\n  frameCtx?: OffscreenCanvasRenderingContext2D;\n\n  constructor() {\n    this.processor = new Processor({\n      modifyFrame: this.modifyFrame.bind(this),\n      progressInit: this.progressInit.bind(this),\n      progressUpdate: this.progressUpdate.bind(this),\n    });\n\n    addEventListener(\"message\", this.onMessage.bind(this)); // eslint-disable-line no-restricted-globals\n  }\n\n  async start(options: {\n    chromaKey: boolean,\n    chromaKeyColor: string,\n\n    fontFiles: FontPackFiles,\n    osdFile: File,\n    srtFile: File,\n    outHandle: FileSystemFileHandle,\n    videoFile: File,\n  }) {\n    this.chromaKey = options.chromaKey;\n    this.chromaKeyColor = options.chromaKeyColor;\n\n    this.osdReader = await OsdReader.fromFile(options.osdFile);\n\n    if (options.srtFile) {\n      this.srtReader = await SrtReader.fromFile(options.srtFile);\n    }\n\n    this.fontPack = await Font.fromFiles(options.fontFiles, this.osdReader);\n\n    const {\n      width,\n      height,\n    } = await this.processor.open(options.videoFile, options.outHandle);\n\n    if (width === 1280 && height === 720) {\n      this.wide = true;\n    }\n\n    if (this.osdReader!.header.config.fontWidth === 24) {\n      this.hd = true;\n    }\n\n    let outWidth: number;\n    let outHeight: number;\n    if (this.wide || this.hd) {\n      outWidth = 1280;\n      outHeight = 720;\n    } else {\n      outWidth = width;\n      outHeight = height;\n    }\n\n    this.outWidth = outWidth;\n    this.outHeight = outHeight;\n\n    this.osdCanvas = new OffscreenCanvas(\n      this.osdReader!.header.config.fontWidth *\n        this.osdReader!.header.config.charWidth,\n      this.osdReader!.header.config.fontHeight *\n        this.osdReader!.header.config.charHeight\n    );\n    this.osdCtx = this.osdCanvas.getContext(\"2d\")!;\n\n    this.frameCanvas = new OffscreenCanvas(this.outWidth!, this.outHeight!);\n    this.frameCtx = this.frameCanvas.getContext(\"2d\")!;\n\n    this.lastOsdIndex = 0;\n\n    try {\n      await this.processor.process({\n        width: outWidth,\n        height: outHeight,\n      });\n\n      this.postMessage({ type: VideoWorkerShared.MessageType.COMPLETE });\n    } catch (e: any) {\n      this.postMessage({\n        type: VideoWorkerShared.MessageType.ERROR,\n        error: e,\n      });\n      throw e;\n    }\n  }\n\n  modifyFrame(frame: ImageBitmap, frameIndex: number): ImageBitmap {\n    const frameCanvas = this.frameCanvas!;\n    const frameCtx = this.frameCtx!;\n    const osdCanvas = this.osdCanvas!;\n    const osdCtx = this.osdCtx!;\n\n    frameCtx.fillStyle = this.chromaKey ? this.chromaKeyColor : \"black\";\n    frameCtx.fillRect(0, 0, frameCanvas.width, frameCanvas.height);\n    osdCtx.clearRect(0, 0, osdCanvas.width, osdCanvas.height);\n\n    if (!this.chromaKey) {\n      let frameXOffset: number;\n      if (this.hd || this.wide) {\n        frameXOffset = (this.outWidth! - frame.width) / 2;\n      } else {\n        frameXOffset = 0;\n      }\n      frameCtx.drawImage(frame, frameXOffset, 0);\n    }\n\n    if (this.lastOsdIndex < this.osdReader!.frames.length - 1) {\n      const nextOsdIndex = this.lastOsdIndex + 1;\n      const nextOsdFrame = this.osdReader!.frames[nextOsdIndex];\n\n      if (frameIndex >= nextOsdFrame.frameNumber) {\n        this.lastOsdIndex = nextOsdIndex;\n      }\n    }\n\n    if (this.srtReader) {\n      // If a srt file is supplied, render the DJI goggle osd elements\n      const drawText = (osdCtx: OffscreenCanvasRenderingContext2D, text: string, x: number, y: number, bigFont = false) => {\n        osdCtx.font = `${bigFont ? \"30px\" : \"26px\"} calibri`;\n        osdCtx.strokeStyle = \"#333333\";\n        osdCtx.lineWidth = 4;\n        osdCtx.strokeText(text, x, y);\n        osdCtx.fillStyle = \"white\";\n        osdCtx.fillText(text, x, y);\n      };\n\n      const currentFrameInMilliseconds = frameIndex * 1000 / 60;\n      let srtFrame = this.srtReader.frames.find((it) => it.start <= currentFrameInMilliseconds && it.end > currentFrameInMilliseconds);\n\n      if (currentFrameInMilliseconds < this.srtReader.frames[0].start) {\n        // DJI subtitles don't start at 0 milliseconds\n        // Take the first one as a filler at the start\n        srtFrame = this.srtReader.frames[0];\n      } else if (currentFrameInMilliseconds > this.srtReader.frames[this.srtReader.frames.length - 1].end) {\n        // Show the last subtitle in case there is more video than subtitles\n        srtFrame = this.srtReader.frames[this.srtReader.frames.length - 1];\n      }\n\n      if (srtFrame) {\n        drawText(osdCtx, srtFrame.ch, 120, 785, true);\n        drawText(osdCtx, srtFrame.delay, 1190, 710);\n        drawText(osdCtx, srtFrame.bitrate, 1320, 710);\n        drawText(osdCtx, srtFrame.uavBat, 1060, 785, true);\n        drawText(osdCtx, srtFrame.flightTime, 1200, 785, true);\n        drawText(osdCtx, srtFrame.glsBat, 1350, 785, true);\n      }\n    }\n\n    const osdFrame = this.osdReader!.frames[this.lastOsdIndex];\n    for (let y = 0; y < MAX_DISPLAY_Y; y++) {\n      for (let x = 0; x < MAX_DISPLAY_X; x++) {\n        const osdFrameIndex = y + MAX_DISPLAY_Y * x;\n        const osdFrameChar = osdFrame.frameData[osdFrameIndex];\n\n        let font: Font;\n        if (this.hd) {\n          font = this.fontPack!.hd;\n        } else {\n          font = this.fontPack!.sd;\n        }\n\n        osdCtx.drawImage(\n          font.getTile(osdFrameChar),\n          x * this.osdReader!.header.config.fontWidth,\n          y * this.osdReader!.header.config.fontHeight\n        );\n      }\n    }\n\n    // Try fit vertically, then try horizontally.\n    let osdScale: number;\n    if (\n      frameCanvas.height / osdCanvas.height <\n      frameCanvas.width / osdCanvas.width\n    ) {\n      osdScale = frameCanvas.height / osdCanvas.height;\n    } else {\n      osdScale = frameCanvas.width / osdCanvas.width;\n    }\n\n    const osdWidth = osdCanvas.width * osdScale;\n    const osdHeight = osdCanvas.height * osdScale;\n\n    const osdXOffset = (frameCanvas.width - osdWidth) / 2;\n    const osdYOffset = (frameCanvas.height - osdHeight) / 2;\n\n    frameCtx.drawImage(osdCanvas, osdXOffset, osdYOffset, osdWidth, osdHeight);\n\n    return frameCanvas.transferToImageBitmap();\n  }\n\n  progressInit(options: {\n    expectedFrames: number;\n  }) {\n    this.postMessage({\n      type: VideoWorkerShared.MessageType.PROGRESS_INIT,\n      ...options,\n    });\n  }\n\n  progressUpdate(options: {\n    framesDecoded?: number;\n    framesDecodedMissing?: number;\n    framesEncoded?: number;\n    preview?: ImageBitmap;\n    queuedForDecode?: number;\n    queuedForEncode?: number;\n    inEncoderQueue?: number;\n    inDecoderQueue?: number;\n  }) {\n    this.postMessage(\n      {\n        type: VideoWorkerShared.MessageType.PROGRESS_UPDATE,\n        ...options,\n      },\n      [...(options.preview ? [options.preview] : [])]\n    );\n  }\n\n  onMessage(event: MessageEvent<VideoWorkerShared.Message>) {\n    const message = event.data;\n    switch (message.type) {\n      case VideoWorkerShared.MessageType.START: {\n        this.start({\n          chromaKey: message.chromaKey,\n          chromaKeyColor: message.chromaKeyColor,\n          fontFiles: message.fontFiles,\n          osdFile: message.osdFile,\n          srtFile: message.srtFile,\n          outHandle: message.outHandle,\n          videoFile: message.videoFile,\n        });\n        break;\n      }\n\n      default: {\n        throw new Error(\"Unknown message type received\");\n      }\n    }\n  }\n\n  private postMessage(message: VideoWorkerShared.Message, transfer?: Transferable[]) {\n    if (transfer) {\n      postMessage(message, transfer);\n    } else {\n      postMessage(message);\n    }\n  }\n}\n\nnew VideoWorker();\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [193], function() { return __webpack_require__(40906); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"34d22fc3\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t906: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkwtfos_configurator\"] = self[\"webpackChunkwtfos_configurator\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(193).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["MessageType","DecoderError","message","name","Error","DecoderConfigureError","EncoderError","EncoderConfigureError","VideoWorkerShared","FileStreamReader","file","buffer","ArrayBuffer","bufferOffset","_offset","this","length","getNextBytes","bytes","byteBuffer","getNextUint8","byte","push","Uint8Array","decoder","TextDecoder","string","decode","getDataView","view","getUint8","getUint16","getUint32","getBigUint64","result","i","offset","bufferEndOffset","size","fillEndOffset","newBufferOffset","Math","floor","BUFFER_SIZE","newBufferEndOffset","ceil","slice","arrayBuffer","fillBuffer","DataView","byteLength","FileStreamWriter","stream","uint8Buffer","uint16Buffer","uint32Buffer","uint64Buffer","uint16View","uint32View","uint64View","_size","Uint16Array","Uint32Array","BigUint64Array","value","writeNextBytes","setUint16","setUint32","BigInt","setBigUint64","undefined","TextEncoder","encodeInto","getStream","write","Blob","seek","close","createWritable","truncate","getMp4Time","date","Date","startDate","getTime","parseBox","startOffset","getNextUint32","getNextString","type","console","debug","Number","getNextUint64","boxParsers","UrlBoxParser","UrnBoxParser","avc1","Avc1BoxParser","avcC","AvcCBoxParser","co64","Co64BoxParser","dinf","DinfBoxParser","dref","DrefBoxParser","ftyp","FtypBoxParser","hdlr","HdrlBoxParser","mdat","MdatBoxParser","mdhd","MdhdBoxParser","mdia","MdiaBoxParser","minf","MinfBoxParser","moov","MoovBoxParser","mvhd","MvhdBoxParser","stbl","StblBoxParser","stco","StcoBoxParser","stsc","StscBoxParser","stsd","StsdBoxParser","stss","StssBoxParser","stsz","StszBoxParser","stts","SttsBoxParser","tkhd","TkhdBoxParser","trak","TrakBoxParser","udta","UdtaBoxParser","vmhd","VmhdBoxParser","ctts","CttsBoxParser","parser","warn","UnknownBoxParser","parse","BoxParser","header","getHeader","endOffset","boxes","getNextChildBox","box","diff","SimpleBoxParser","seekToEnd","FullBoxParser","version","flags","getFullBoxHeader","fullBoxHeader","majorBrand","minorVersion","compatibleBrands","getChildBoxes","childBoxes","creationTime","modificationTime","timescale","duration","rate","getNextUint16","volume","matrix","nextTrackId","trackId","layer","alternateGroup","width","height","languageBytes","language","String","fromCharCode","entryCount","entries","nextChild","dataReferenceIndex","horizontalResolution","verticalResolution","frameCount","compressorName","depth","configurationVersion","profileIndication","profileCompatibility","levelIndication","lengthSizeMinusOne","spsCount","sps","spsLength","spsData","ppsCount","pps","ppsLength","ppsData","sequenceParameterSets","pictureParameterSets","sampleNumbers","chunkOffsets","firstChunk","samplesPerChunk","sampleDescriptionIndex","sampleSizes","sampleCount","sampleDelta","handlerType","graphicsMode","opColor","sampleCounts","sampleOffsets","location","writeBox","writer","UrlBoxWriter","UrnBoxWriter","Avc1BoxWriter","AvcCBoxWriter","DinfBoxWriter","DrefBoxWriter","FtypBoxWriter","HdlrBoxWriter","MdhdBoxWriter","MdiaBoxWriter","MinfBoxWriter","MoovBoxWriter","MvhdBoxWriter","StblBoxWriter","StcoBoxWriter","StscBoxWriter","StsdBoxWriter","StssBoxWriter","StszBoxWriter","SttsBoxWriter","TkhdBoxWriter","TrakBoxWriter","VmhdBoxWriter","BoxWriter","writeNextUint32","writeNextString","writeContents","FullBoxWriter","writeNextUint8","compatibleBrand","sequenceParameterSet","writeNextUint16","skip","entry","color","chunkOffset","sampleSize","sampleNumber","MdatBoxStreamWriter","sizeOffset","opened","closed","writeNextUint64","MP4Parser","eof","sampleOffset","isSampleSync","data","sync","includes","MP4Writer","syncSamples","displaySize","frameRate","open","avcCStruct","byteOffset","options","framerate","getMvhdBox","getTrakBox","getTkhdBox","getMdiaBox","nowMp4Time","getMinfBox","getMdhdBox","getStblBox","getDinfBox","dataStartOffset","avcCBoxToDescription","avcCBox","StreamDataView","setNextUint8","setNextUint16","j","getBuffer","Processor","encoder","inMp4","outMp4","expectedFrames","framesDecoded","framesDecodedMissing","framesEncoded","queuedForDecode","queuedForEncode","modifyFrame","progressInit","progressUpdate","processResolve","processReject","progressUpdateIntervalHandle","decodedFrames","encodedFrames","sendProgressUpdate","bind","outHandle","reset","Promise","resolve","reject","avc1box","codec","toString","padStart","configure","codedWidth","codedHeight","description","optimizeForLatency","e","bitrate","latencyMode","scalabilityMode","setDisplaySize","setFramerate","self","setInterval","processSamples","VideoEncoder","output","handleEncodedFrame","error","handleEncoderError","VideoDecoder","handleDecodedFrame","handleDecoderError","clearInterval","lastSampleIndex","sampleChunks","sampleIndex","getSample","sample","index","chunk","image","encodedChunk","EncodedVideoChunk","timestamp","flush","orderedFrames","reorderFrames","modifiedFrame","frame","VideoFrame","preview","encode","keyFrame","writeSample","initialOffset","Object","keys","frameNumber","reduce","acc","newPosition","assign","createImageBitmap","metadata","copyTo","setAvcC","decoderConfig","inDecoderQueue","decodeQueueSize","inEncoderQueue","encodeQueueSize","Font","tiles","isHd","reader","font_filename","config","fontVariant","toLowerCase","fetch","then","response","filename","tileWidth","tileHeight","imageBitmap","canvas","OffscreenCanvas","context","getContext","drawImage","tilesPerColumn","columns","columnIndex","rowIndex","x","y","imageData","getImageData","tileBitmap","files","fromFile","sd","hd","OsdReader","frames","magic","charWidth","charHeight","fontWidth","fontHeight","xOffset","yOffset","substring","resetOffset","getOffset","frameSize","frameData","setOffset","RangeError","SrtReader","blocks","split","timestamps","text","map","it","parseInt","startHours","startMinutes","startSeconds","startMilliseconds","endHours","endMinutes","endSeconds","endMilliseconds","start","end","signalRaw","chRaw","flightTimeRaw","uavBatRaw","glsBatRaw","uavBatCellsRaw","glsBatCellsRaw","delayRaw","bitrateRaw","rcSignalRaw","signal","ch","flightTime","uavBat","glsBat","uavBatCells","glsBatCells","delay","rcSignal","totalSeconds","minutes","seconds","formatFlightTime","VideoWorker","processor","chromaKey","chromaKeyColor","fontPack","osdReader","srtReader","lastOsdIndex","wide","outWidth","outHeight","osdCanvas","osdCtx","frameCanvas","frameCtx","addEventListener","onMessage","osdFile","srtFile","fromFiles","fontFiles","videoFile","process","postMessage","frameIndex","frameXOffset","fillStyle","fillRect","clearRect","nextOsdIndex","drawText","bigFont","font","strokeStyle","lineWidth","strokeText","fillText","currentFrameInMilliseconds","srtFrame","find","osdScale","osdFrame","osdFrameIndex","osdFrameChar","getTile","osdWidth","osdHeight","osdXOffset","osdYOffset","transferToImageBitmap","event","transfer","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","every","key","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","get","f","chunkId","all","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","moreModules","runtime","pop","next"],"sourceRoot":""}